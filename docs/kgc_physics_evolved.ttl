@prefix kgc: <http://bitflow.ai/ontology/kgc/v3#> .
@prefix yawl: <http://www.yawlfoundation.org/yawlschema#> .
@prefix time: <http://www.w3.org/2006/time#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .

# =============================================================================
# KGC PHYSICS ONTOLOGY v4.0 - EXECUTABLE PARAMETERS
# =============================================================================
#
# EVOLUTION: Parameters are no longer scalar values - they are EXECUTION TEMPLATES
#
# BEFORE (v3.1): :WCP-2-Mapping kgc:hasCardinality "topology" .
# AFTER  (v4.0): :WCP-2-Mapping kgc:hasCardinality :CardinalityTopology .
#                :CardinalityTopology kgc:executionTemplate "SPARQL query..." .
#
# THE CHATMAN EQUATION: A = μ(O, P)
# ---------------------------------
# Now P (Parameters) are QUERIES, not VALUES.
# The Kernel retrieves and executes the template instead of Python if/else.
#
# =============================================================================

<http://bitflow.ai/ontology/kgc/v4#>
    a owl:Ontology ;
    rdfs:label "KGC Physics Ontology v4"@en ;
    rdfs:comment "Executable parameter ontology. Parameters ARE execution templates."@en ;
    owl:versionInfo "4.0.0" ;
    owl:priorVersion <http://bitflow.ai/ontology/kgc/v3#> .

# =============================================================================
# SECTION 1: EXECUTION TEMPLATE INFRASTRUCTURE
# =============================================================================

kgc:ExecutionTemplate a rdfs:Class ;
    rdfs:label "Execution Template"@en ;
    rdfs:comment "A SPARQL query template that implements parameter behavior."@en .

kgc:executionTemplate a rdf:Property ;
    rdfs:label "execution template"@en ;
    rdfs:domain kgc:ParameterValue ;
    rdfs:range xsd:string ;
    rdfs:comment "SPARQL query that implements this parameter's behavior."@en .

kgc:ParameterValue a rdfs:Class ;
    rdfs:label "Parameter Value"@en ;
    rdfs:comment "A parameter value with associated execution logic."@en .

kgc:templateVariables a rdf:Property ;
    rdfs:label "template variables"@en ;
    rdfs:domain kgc:ParameterValue ;
    rdfs:range xsd:string ;
    rdfs:comment "JSON schema of variables the template expects (e.g., ?source, ?context)."@en .

kgc:returnType a rdf:Property ;
    rdfs:label "return type"@en ;
    rdfs:domain kgc:ParameterValue ;
    rdfs:range rdfs:Resource ;
    rdfs:comment "Expected return type: 'count', 'uris', 'boolean', etc."@en .

# =============================================================================
# SECTION 2: THRESHOLD PARAMETER VALUES (For AWAIT verb)
# =============================================================================

kgc:ThresholdAll a kgc:ParameterValue ;
    rdfs:label "Threshold: All"@en ;
    kgc:executionTemplate """
        # COUNT all incoming flows to this task
        SELECT (COUNT(?incoming) AS ?threshold) WHERE {
            ?source yawl:flowsInto ?flow .
            ?flow yawl:nextElementRef ?task .
            BIND(?task AS ?context)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The target task URI\"}" ;
    kgc:returnType "count" ;
    rdfs:comment "Wait for ALL incoming branches to complete."@en .

kgc:ThresholdOne a kgc:ParameterValue ;
    rdfs:label "Threshold: One"@en ;
    kgc:executionTemplate """
        # Return threshold of 1 (wait for first arrival)
        SELECT (1 AS ?threshold) WHERE {}
    """ ;
    kgc:templateVariables "{}" ;
    kgc:returnType "count" ;
    rdfs:comment "Wait for FIRST arrival (discriminator pattern)."@en .

kgc:ThresholdActive a kgc:ParameterValue ;
    rdfs:label "Threshold: Active"@en ;
    kgc:executionTemplate """
        # COUNT incoming flows that are NOT voided
        SELECT (COUNT(?incoming) AS ?threshold) WHERE {
            ?source yawl:flowsInto ?flow .
            ?flow yawl:nextElementRef ?task .
            FILTER NOT EXISTS {
                ?source kgc:status "Voided"
            }
            BIND(?task AS ?context)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The target task URI\"}" ;
    kgc:returnType "count" ;
    rdfs:comment "Wait for all ACTIVE (non-voided) branches."@en .

kgc:ThresholdStatic a kgc:ParameterValue ;
    rdfs:label "Threshold: Static"@en ;
    kgc:executionTemplate """
        # Return static threshold from MI task definition
        SELECT ?threshold WHERE {
            ?task yawl:miThreshold ?threshold .
            FILTER(isLiteral(?threshold))
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The MI task URI\"}" ;
    kgc:returnType "count" ;
    rdfs:comment "Static threshold (N of M instances)."@en .

kgc:ThresholdDynamic a kgc:ParameterValue ;
    rdfs:label "Threshold: Dynamic"@en ;
    kgc:executionTemplate """
        # Evaluate runtime expression for threshold
        SELECT ?threshold WHERE {
            ?task yawl:miThreshold ?expr .
            FILTER(!isLiteral(?expr))
            # Expression evaluation happens in runtime context
            # This template signals: "evaluate ?expr at runtime"
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The MI task URI\", \"runtimeContext\": \"Execution state\"}" ;
    kgc:returnType "expression" ;
    rdfs:comment "Dynamic threshold computed at runtime."@en .

kgc:ThresholdMilestone a kgc:ParameterValue ;
    rdfs:label "Threshold: Milestone"@en ;
    kgc:executionTemplate """
        # Check if milestone condition is currently satisfied
        SELECT ?satisfied WHERE {
            ?task yawl:milestoneCondition ?condition .
            # Condition is evaluated against current graph state
            BIND(EXISTS { ?condition } AS ?satisfied)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Task with milestone\", \"graphState\": \"Current execution graph\"}" ;
    kgc:returnType "boolean" ;
    rdfs:comment "Milestone-based threshold (state condition)."@en .

kgc:ThresholdSignal a kgc:ParameterValue ;
    rdfs:label "Threshold: Signal"@en ;
    kgc:executionTemplate """
        # Check for transient signal event
        SELECT ?signal WHERE {
            ?task yawl:triggeredBy ?signal .
            ?signal a yawl:TransientTrigger .
            ?signal kgc:receivedAt ?timestamp .
            # Signal must be recent (transient)
            FILTER(?timestamp >= ?currentTime - "PT1S"^^xsd:duration)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Task URI\", \"currentTime\": \"Current timestamp\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Transient signal trigger."@en .

kgc:ThresholdPersistent a kgc:ParameterValue ;
    rdfs:label "Threshold: Persistent"@en ;
    kgc:executionTemplate """
        # Check for persistent signal (remains until consumed)
        SELECT ?signal WHERE {
            ?task yawl:triggeredBy ?signal .
            ?signal a yawl:PersistentTrigger .
            ?signal kgc:status "Active" .
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Task URI\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Persistent signal trigger."@en .

# =============================================================================
# SECTION 3: CARDINALITY PARAMETER VALUES (For COPY verb)
# =============================================================================

kgc:CardinalityTopology a kgc:ParameterValue ;
    rdfs:label "Cardinality: Topology"@en ;
    kgc:executionTemplate """
        # COUNT outgoing flows from this task
        SELECT (COUNT(?outgoing) AS ?cardinality) WHERE {
            ?source yawl:flowsInto ?flow .
            ?flow yawl:nextElementRef ?target .
            BIND(?source AS ?context)
        }
    """ ;
    kgc:templateVariables "{\"source\": \"The source task URI\"}" ;
    kgc:returnType "count" ;
    rdfs:comment "Cardinality determined by topology (number of outgoing edges)."@en .

kgc:CardinalityStatic a kgc:ParameterValue ;
    rdfs:label "Cardinality: Static"@en ;
    kgc:executionTemplate """
        # Return static cardinality from MI task
        SELECT ?cardinality WHERE {
            ?task yawl:minimum ?min .
            ?task yawl:maximum ?max .
            FILTER(?min = ?max)
            BIND(?min AS ?cardinality)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The MI task URI\"}" ;
    kgc:returnType "count" ;
    rdfs:comment "Static cardinality (N known at design time)."@en .

kgc:CardinalityDynamic a kgc:ParameterValue ;
    rdfs:label "Cardinality: Dynamic"@en ;
    kgc:executionTemplate """
        # Determine cardinality from runtime data collection
        SELECT (COUNT(?item) AS ?cardinality) WHERE {
            ?task yawl:miDataInput ?collection .
            ?collection rdf:rest* ?node .
            ?node rdf:first ?item .
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The MI task URI\", \"runtimeData\": \"Input data collection\"}" ;
    kgc:returnType "count" ;
    rdfs:comment "Dynamic cardinality (determined from data at runtime)."@en .

kgc:CardinalityIncremental a kgc:ParameterValue ;
    rdfs:label "Cardinality: Incremental"@en ;
    kgc:executionTemplate """
        # Incremental MI: cardinality grows during execution
        SELECT (COUNT(?instance) AS ?cardinality) WHERE {
            ?task yawl:hasInstance ?instance .
            ?instance kgc:status "Active" .
            # Returns current count, may increase over time
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The MI task URI\"}" ;
    kgc:returnType "count" ;
    rdfs:comment "Incremental cardinality (grows during execution)."@en .

kgc:CardinalityOne a kgc:ParameterValue ;
    rdfs:label "Cardinality: One"@en ;
    kgc:executionTemplate """
        # Single copy (for recursion, service invocation)
        SELECT (1 AS ?cardinality) WHERE {}
    """ ;
    kgc:templateVariables "{}" ;
    kgc:returnType "count" ;
    rdfs:comment "Single copy operation."@en .

# =============================================================================
# SECTION 4: COMPLETION STRATEGY PARAMETER VALUES (For AWAIT verb)
# =============================================================================

kgc:CompletionWaitAll a kgc:ParameterValue ;
    rdfs:label "Completion: Wait All"@en ;
    kgc:executionTemplate """
        # Check if ALL expected tokens have arrived
        SELECT ?complete WHERE {
            {
                SELECT (COUNT(?expected) AS ?expectedCount) WHERE {
                    ?source yawl:flowsInto ?flow .
                    ?flow yawl:nextElementRef ?task .
                }
            }
            {
                SELECT (COUNT(?token) AS ?tokenCount) WHERE {
                    ?task kgc:hasReceivedToken ?token .
                }
            }
            BIND(?tokenCount >= ?expectedCount AS ?complete)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The join task URI\"}" ;
    kgc:returnType "boolean" ;
    rdfs:comment "Wait for ALL tokens to arrive (AND-join)."@en .

kgc:CompletionWaitActive a kgc:ParameterValue ;
    rdfs:label "Completion: Wait Active"@en ;
    kgc:executionTemplate """
        # Check if all ACTIVE (non-voided) tokens arrived
        SELECT ?complete WHERE {
            {
                SELECT (COUNT(?expected) AS ?expectedCount) WHERE {
                    ?source yawl:flowsInto ?flow .
                    ?flow yawl:nextElementRef ?task .
                    FILTER NOT EXISTS { ?source kgc:status "Voided" }
                }
            }
            {
                SELECT (COUNT(?token) AS ?tokenCount) WHERE {
                    ?task kgc:hasReceivedToken ?token .
                }
            }
            BIND(?tokenCount >= ?expectedCount AS ?complete)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The OR-join task URI\"}" ;
    kgc:returnType "boolean" ;
    rdfs:comment "Wait for all ACTIVE branches (OR-join)."@en .

kgc:CompletionWaitFirst a kgc:ParameterValue ;
    rdfs:label "Completion: Wait First"@en ;
    kgc:executionTemplate """
        # Check if at least one token arrived
        SELECT ?complete WHERE {
            BIND(EXISTS { ?task kgc:hasReceivedToken ?token } AS ?complete)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The discriminator task URI\"}" ;
    kgc:returnType "boolean" ;
    rdfs:comment "Wait for FIRST token only (discriminator)."@en .

kgc:CompletionWaitQuorum a kgc:ParameterValue ;
    rdfs:label "Completion: Wait Quorum"@en ;
    kgc:executionTemplate """
        # Check if threshold number of tokens arrived
        SELECT ?complete WHERE {
            ?task yawl:miThreshold ?threshold .
            {
                SELECT (COUNT(?token) AS ?tokenCount) WHERE {
                    ?task kgc:hasReceivedToken ?token .
                }
            }
            BIND(?tokenCount >= ?threshold AS ?complete)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"The MI join task URI\"}" ;
    kgc:returnType "boolean" ;
    rdfs:comment "Wait for quorum (N of M instances)."@en .

kgc:CompletionWaitMilestone a kgc:ParameterValue ;
    rdfs:label "Completion: Wait Milestone"@en ;
    kgc:executionTemplate """
        # Check if milestone condition still holds
        SELECT ?complete WHERE {
            ?task yawl:milestoneCondition ?condition .
            # Milestone must be ENABLED (not just satisfied in past)
            BIND(EXISTS {
                ?condition kgc:status "Active" .
                ?task kgc:hasReceivedToken ?token .
            } AS ?complete)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Task with milestone\"}" ;
    kgc:returnType "boolean" ;
    rdfs:comment "Wait for milestone enablement."@en .

kgc:CompletionWaitSignal a kgc:ParameterValue ;
    rdfs:label "Completion: Wait Signal"@en ;
    kgc:executionTemplate """
        # Check for signal arrival
        SELECT ?complete WHERE {
            ?task yawl:triggeredBy ?signal .
            BIND(EXISTS { ?signal kgc:receivedAt ?time } AS ?complete)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Signal-triggered task\"}" ;
    kgc:returnType "boolean" ;
    rdfs:comment "Wait for external signal."@en .

kgc:CompletionWaitCallback a kgc:ParameterValue ;
    rdfs:label "Completion: Wait Callback"@en ;
    kgc:executionTemplate """
        # Check for async service callback
        SELECT ?complete WHERE {
            ?task yawl:invokedService ?service .
            ?service kgc:callbackReceived ?callback .
            BIND(EXISTS { ?callback a kgc:ServiceResponse } AS ?complete)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Async service task\"}" ;
    kgc:returnType "boolean" ;
    rdfs:comment "Wait for async callback."@en .

# =============================================================================
# SECTION 5: SELECTION MODE PARAMETER VALUES (For FILTER verb)
# =============================================================================

kgc:SelectionExactlyOne a kgc:ParameterValue ;
    rdfs:label "Selection: Exactly One"@en ;
    kgc:executionTemplate """
        # Evaluate guards, return exactly one matching branch
        SELECT ?selected WHERE {
            ?source yawl:flowsInto ?flow .
            ?flow yawl:nextElementRef ?target .
            ?flow yawl:guard ?guard .
            # Evaluate guard in runtime context
            FILTER(kgc:evaluateGuard(?guard, ?runtimeContext))
        }
        LIMIT 1
    """ ;
    kgc:templateVariables "{\"source\": \"Source task\", \"runtimeContext\": \"Runtime state for guard evaluation\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "XOR-split: exactly one branch selected."@en .

kgc:SelectionOneOrMore a kgc:ParameterValue ;
    rdfs:label "Selection: One Or More"@en ;
    kgc:executionTemplate """
        # Evaluate all guards, return ALL matching branches
        SELECT ?selected WHERE {
            ?source yawl:flowsInto ?flow .
            ?flow yawl:nextElementRef ?target .
            ?flow yawl:guard ?guard .
            FILTER(kgc:evaluateGuard(?guard, ?runtimeContext))
        }
    """ ;
    kgc:templateVariables "{\"source\": \"Source task\", \"runtimeContext\": \"Runtime state\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "OR-split: one or more branches selected."@en .

kgc:SelectionDeferred a kgc:ParameterValue ;
    rdfs:label "Selection: Deferred"@en ;
    kgc:executionTemplate """
        # Activate all branches, let environment/resource select
        SELECT ?enabled WHERE {
            ?source yawl:flowsInto ?flow .
            ?flow yawl:nextElementRef ?target .
            # All branches are ENABLED, actual selection deferred
        }
    """ ;
    kgc:templateVariables "{\"source\": \"Source task\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Deferred choice: environment selects at runtime."@en .

kgc:SelectionMutex a kgc:ParameterValue ;
    rdfs:label "Selection: Mutex"@en ;
    kgc:executionTemplate """
        # Enable all branches but enforce mutual exclusion
        SELECT ?enabled WHERE {
            ?source yawl:flowsInto ?flow .
            ?flow yawl:nextElementRef ?target .
            # Mark all as ENABLED with mutex constraint
            BIND(?target AS ?enabled)
        }
    """ ;
    kgc:templateVariables "{\"source\": \"Source task\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Interleaved parallel: one at a time (mutex)."@en .

kgc:SelectionLoopCondition a kgc:ParameterValue ;
    rdfs:label "Selection: Loop Condition"@en ;
    kgc:executionTemplate """
        # Evaluate loop condition, select continue or exit
        SELECT ?selected WHERE {
            ?source yawl:loopCondition ?condition .
            ?source yawl:flowsInto ?continueFlow .
            ?continueFlow yawl:isLoopBack true .
            ?source yawl:flowsInto ?exitFlow .
            ?exitFlow yawl:isLoopBack false .
            # If condition true, select continue; else select exit
            BIND(IF(kgc:evaluateCondition(?condition, ?runtimeContext),
                    ?continueFlow, ?exitFlow) AS ?selected)
        }
    """ ;
    kgc:templateVariables "{\"source\": \"Loop task\", \"runtimeContext\": \"Runtime state\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Structured loop: condition-based selection."@en .

kgc:SelectionWhileTrue a kgc:ParameterValue ;
    rdfs:label "Selection: While True"@en ;
    kgc:executionTemplate """
        # Pre-test loop: evaluate BEFORE iteration
        SELECT ?selected WHERE {
            ?source yawl:whileCondition ?condition .
            ?source yawl:flowsInto ?loopBody .
            ?loopBody yawl:isLoopEntry true .
            ?source yawl:flowsInto ?loopExit .
            ?loopExit yawl:isLoopExit true .
            BIND(IF(kgc:evaluateCondition(?condition, ?runtimeContext),
                    ?loopBody, ?loopExit) AS ?selected)
        }
    """ ;
    kgc:templateVariables "{\"source\": \"While loop\", \"runtimeContext\": \"Runtime state\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "While loop: pre-test condition."@en .

kgc:SelectionUntilTrue a kgc:ParameterValue ;
    rdfs:label "Selection: Until True"@en ;
    kgc:executionTemplate """
        # Post-test loop: evaluate AFTER iteration
        SELECT ?selected WHERE {
            ?source yawl:untilCondition ?condition .
            ?source yawl:flowsInto ?loopBody .
            ?loopBody yawl:isLoopBack true .
            ?source yawl:flowsInto ?loopExit .
            ?loopExit yawl:isLoopExit true .
            # Inverse: continue UNTIL condition is true
            BIND(IF(!kgc:evaluateCondition(?condition, ?runtimeContext),
                    ?loopBody, ?loopExit) AS ?selected)
        }
    """ ;
    kgc:templateVariables "{\"source\": \"Repeat-until loop\", \"runtimeContext\": \"Runtime state\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Repeat-until: post-test condition."@en .

kgc:SelectionAuthorized a kgc:ParameterValue ;
    rdfs:label "Selection: Authorized"@en ;
    kgc:executionTemplate """
        # Filter resources by authorization
        SELECT ?authorized WHERE {
            ?task yawl:requiresRole ?role .
            ?resource yawl:hasRole ?role .
            ?resource kgc:isAvailable true .
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Task requiring resource\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Resource authorization filter."@en .

kgc:SelectionRoleMatch a kgc:ParameterValue ;
    rdfs:label "Selection: Role Match"@en ;
    kgc:executionTemplate """
        # Allocate task to resources matching role
        SELECT ?participant WHERE {
            ?task yawl:allocatedTo ?role .
            ?participant yawl:hasRole ?role .
            ?participant kgc:workload ?load .
        }
        ORDER BY ASC(?load)
        LIMIT 1
    """ ;
    kgc:templateVariables "{\"task\": \"Task for allocation\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Role-based allocation with load balancing."@en .

# =============================================================================
# SECTION 6: CANCELLATION SCOPE PARAMETER VALUES (For VOID verb)
# =============================================================================

kgc:CancellationSelf a kgc:ParameterValue ;
    rdfs:label "Cancellation: Self"@en ;
    kgc:executionTemplate """
        # Void only this task's token
        SELECT ?target WHERE {
            BIND(?task AS ?target)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Task to cancel\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Cancel self only."@en .

kgc:CancellationRegion a kgc:ParameterValue ;
    rdfs:label "Cancellation: Region"@en ;
    kgc:executionTemplate """
        # Void all tasks in cancellation region
        SELECT ?target WHERE {
            ?task yawl:cancellationRegion ?region .
            ?region yawl:contains ?target .
            ?target kgc:status "Active" .
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Task triggering cancellation\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Cancel all tasks in region."@en .

kgc:CancellationCase a kgc:ParameterValue ;
    rdfs:label "Cancellation: Case"@en ;
    kgc:executionTemplate """
        # Void all tasks in this case instance
        SELECT ?target WHERE {
            ?case a yawl:CaseInstance .
            ?target yawl:belongsToCase ?case .
            ?target kgc:status "Active" .
        }
    """ ;
    kgc:templateVariables "{\"case\": \"Case instance to cancel\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Cancel entire case."@en .

kgc:CancellationInstances a kgc:ParameterValue ;
    rdfs:label "Cancellation: Instances"@en ;
    kgc:executionTemplate """
        # Void all instances of MI task
        SELECT ?target WHERE {
            ?task yawl:hasInstance ?instance .
            ?instance kgc:status "Active" .
            BIND(?instance AS ?target)
        }
    """ ;
    kgc:templateVariables "{\"task\": \"MI task\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Cancel all MI instances."@en .

kgc:CancellationTask a kgc:ParameterValue ;
    rdfs:label "Cancellation: Task"@en ;
    kgc:executionTemplate """
        # Void specific task and transition to exception handler
        SELECT ?target WHERE {
            BIND(?task AS ?target)
            # Exception handler will be invoked after voiding
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Task that raised exception\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Cancel task on exception."@en .

kgc:CancellationSubprocess a kgc:ParameterValue ;
    rdfs:label "Cancellation: Subprocess"@en ;
    kgc:executionTemplate """
        # Void entire subprocess tree
        SELECT ?target WHERE {
            ?task yawl:invokesSubprocess ?subprocess .
            ?subprocess yawl:contains+ ?target .
            ?target kgc:status "Active" .
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Parent task invoking subprocess\"}" ;
    kgc:returnType "uris" ;
    rdfs:comment "Cancel subprocess and all nested tasks."@en .

# =============================================================================
# SECTION 7: RESET ON FIRE PARAMETER VALUES (For AWAIT verb)
# =============================================================================

kgc:ResetTrue a kgc:ParameterValue ;
    rdfs:label "Reset: True"@en ;
    kgc:executionTemplate """
        # Clear join state after firing (for loops)
        SELECT ?action WHERE {
            BIND("CLEAR_TOKENS" AS ?action)
            # After AWAIT completes, remove all received tokens
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Join task in loop\"}" ;
    kgc:returnType "action" ;
    rdfs:comment "Reset join state after firing (loop discriminator)."@en .

kgc:ResetFalse a kgc:ParameterValue ;
    rdfs:label "Reset: False"@en ;
    kgc:executionTemplate """
        # Keep join state (for non-repeating joins)
        SELECT ?action WHERE {
            BIND("PRESERVE_TOKENS" AS ?action)
        }
    """ ;
    kgc:templateVariables "{}" ;
    kgc:returnType "action" ;
    rdfs:comment "Preserve join state (one-shot join)."@en .

# =============================================================================
# SECTION 8: INSTANCE BINDING PARAMETER VALUES (For MI patterns)
# =============================================================================

kgc:InstanceBindingNone a kgc:ParameterValue ;
    rdfs:label "Instance Binding: None"@en ;
    kgc:executionTemplate """
        # No specific binding (uniform instances)
        SELECT ?binding WHERE {
            BIND("UNIFORM" AS ?binding)
        }
    """ ;
    kgc:templateVariables "{}" ;
    kgc:returnType "constant" ;
    rdfs:comment "No instance-specific binding."@en .

kgc:InstanceBindingIndex a kgc:ParameterValue ;
    rdfs:label "Instance Binding: Index"@en ;
    kgc:executionTemplate """
        # Bind instance to its index (0..N-1)
        SELECT ?instance ?index WHERE {
            ?task yawl:hasInstance ?instance .
            # Generate index based on creation order
        }
        ORDER BY ?instance
    """ ;
    kgc:templateVariables "{\"task\": \"MI task\"}" ;
    kgc:returnType "bindings" ;
    rdfs:comment "Index-based binding (0, 1, 2, ...)."@en .

kgc:InstanceBindingData a kgc:ParameterValue ;
    rdfs:label "Instance Binding: Data"@en ;
    kgc:executionTemplate """
        # Bind instance to data item from collection
        SELECT ?instance ?data WHERE {
            ?task yawl:miDataInput ?collection .
            ?collection rdf:rest* ?node .
            ?node rdf:first ?data .
            ?task yawl:hasInstance ?instance .
            ?instance kgc:boundTo ?data .
        }
    """ ;
    kgc:templateVariables "{\"task\": \"MI task with data binding\"}" ;
    kgc:returnType "bindings" ;
    rdfs:comment "Data-driven binding (one instance per data item)."@en .

kgc:InstanceBindingRecursive a kgc:ParameterValue ;
    rdfs:label "Instance Binding: Recursive"@en ;
    kgc:executionTemplate """
        # Bind subprocess instance to parent context
        SELECT ?instance ?parent WHERE {
            ?parent yawl:invokesSubprocess ?instance .
            ?instance kgc:parentInstance ?parent .
        }
    """ ;
    kgc:templateVariables "{\"task\": \"Recursive subprocess invocation\"}" ;
    kgc:returnType "bindings" ;
    rdfs:comment "Recursive subprocess binding."@en .

# =============================================================================
# SECTION 9: UPDATED PATTERN MAPPINGS (Using New Parameter Values)
# =============================================================================

# Example: WCP-2 Parallel Split with executable cardinality
kgc:WCP2_ParallelSplit a kgc:PatternMapping ;
    rdfs:label "WCP-2: Parallel Split → Copy"@en ;
    kgc:pattern yawl:ControlTypeAnd ;
    kgc:triggerProperty yawl:hasSplit ;
    kgc:triggerValue yawl:ControlTypeAnd ;
    kgc:verb kgc:Copy ;
    kgc:hasCardinality kgc:CardinalityTopology ;  # NOW A RESOURCE, NOT A STRING
    rdfs:comment "Divergence into multiple parallel branches."@en .

# Example: WCP-3 Synchronization with executable threshold
kgc:WCP3_Synchronization a kgc:PatternMapping ;
    rdfs:label "WCP-3: Synchronization → Await(all)"@en ;
    kgc:pattern yawl:ControlTypeAnd ;
    kgc:triggerProperty yawl:hasJoin ;
    kgc:triggerValue yawl:ControlTypeAnd ;
    kgc:verb kgc:Await ;
    kgc:hasThreshold kgc:ThresholdAll ;          # NOW A RESOURCE, NOT A STRING
    kgc:completionStrategy kgc:CompletionWaitAll ; # NOW A RESOURCE, NOT A STRING
    rdfs:comment "Convergence requiring ALL branches to complete."@en .

# Example: WCP-4 Exclusive Choice with executable selection mode
kgc:WCP4_ExclusiveChoice a kgc:PatternMapping ;
    rdfs:label "WCP-4: Exclusive Choice → Filter(exactlyOne)"@en ;
    kgc:pattern yawl:ControlTypeXor ;
    kgc:triggerProperty yawl:hasSplit ;
    kgc:triggerValue yawl:ControlTypeXor ;
    kgc:verb kgc:Filter ;
    kgc:selectionMode kgc:SelectionExactlyOne ;  # NOW A RESOURCE, NOT A STRING
    rdfs:comment "Exactly ONE branch selected based on predicate."@en .

# Example: WCP-7 OR-join with active threshold
kgc:WCP7_StructuredSyncMerge a kgc:PatternMapping ;
    rdfs:label "WCP-7: Sync Merge → Await(waitActive)"@en ;
    kgc:pattern yawl:ControlTypeOr ;
    kgc:triggerProperty yawl:hasJoin ;
    kgc:triggerValue yawl:ControlTypeOr ;
    kgc:verb kgc:Await ;
    kgc:hasThreshold kgc:ThresholdActive ;           # EXECUTABLE
    kgc:completionStrategy kgc:CompletionWaitActive ; # EXECUTABLE
    rdfs:comment "Wait for all ACTIVE branches (not voided)."@en .

# Example: WCP-9 Discriminator with reset
kgc:WCP9_Discriminator a kgc:PatternMapping ;
    rdfs:label "WCP-9: Discriminator → Await(1)"@en ;
    kgc:pattern yawl:Discriminator ;
    kgc:verb kgc:Await ;
    kgc:hasThreshold kgc:ThresholdOne ;              # EXECUTABLE
    kgc:completionStrategy kgc:CompletionWaitFirst ; # EXECUTABLE
    kgc:resetOnFire kgc:ResetTrue ;                  # EXECUTABLE
    rdfs:comment "Fire on first arrival, ignore subsequent."@en .

# Example: WCP-14 MI with dynamic cardinality and data binding
kgc:WCP14_MIRuntime a kgc:PatternMapping ;
    rdfs:label "WCP-14: MI Runtime → Copy(dynamic)+Await(all)"@en ;
    kgc:pattern yawl:MultiInstanceTask ;
    kgc:condition "ASK { ?task yawl:miDataInput ?input }" ;
    kgc:verb kgc:Copy ;
    kgc:hasCardinality kgc:CardinalityDynamic ;    # EXECUTABLE
    kgc:instanceBinding kgc:InstanceBindingData ;  # EXECUTABLE
    rdfs:comment "N determined at runtime from data."@en .

# Example: WCP-21 Cancel Region with executable scope
kgc:WCP21_CancelRegion a kgc:PatternMapping ;
    rdfs:label "WCP-21: Cancel Region → Void(region)"@en ;
    kgc:pattern yawl:CancellationRegion ;
    kgc:verb kgc:Void ;
    kgc:cancellationScope kgc:CancellationRegion ;  # EXECUTABLE
    rdfs:comment "Void all tasks in cancellation set."@en .

# =============================================================================
# SECTION 10: KERNEL INTEGRATION INSTRUCTIONS
# =============================================================================

# USAGE PATTERN FOR KERNEL:
#
# 1. DISCOVERY: Find pattern mapping via SPARQL
#    SELECT ?mapping ?verb ?param WHERE {
#        ?node yawl:hasSplit yawl:ControlTypeAnd .
#        ?mapping kgc:triggerProperty yawl:hasSplit ;
#                 kgc:triggerValue yawl:ControlTypeAnd ;
#                 kgc:verb ?verb ;
#                 kgc:hasCardinality ?param .
#    }
#    # Result: ?verb = kgc:Copy, ?param = kgc:CardinalityTopology
#
# 2. RETRIEVAL: Get execution template
#    SELECT ?template ?variables WHERE {
#        kgc:CardinalityTopology kgc:executionTemplate ?template ;
#                                kgc:templateVariables ?variables .
#    }
#
# 3. EXECUTION: Run template with context
#    Execute SPARQL query from ?template with variables from ?variables
#    Result: Concrete cardinality value (e.g., "3")
#
# 4. VERB DISPATCH: Call verb with computed parameter
#    copy_verb.execute(source=task, cardinality=3, graph=current_graph)
#
# NO PYTHON IF/ELSE. ALL LOGIC IS IN RDF + SPARQL.

# =============================================================================
# END OF KGC PHYSICS ONTOLOGY v4.0
# =============================================================================
