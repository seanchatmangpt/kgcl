"""Pytest fixtures for KGC Hybrid Engine tests.

Provides N3 rules, workflow topologies, engine instances, and RDF stores.
"""

from collections.abc import Iterator
from typing import Any

import pytest
from pyoxigraph import Store

# Assume HybridEngine exists (will be implemented)
# from kgcl.hybrid_engine.core import HybridEngine


# =============================================================================
# N3 Rule Fixtures (Workflow Control Patterns)
# =============================================================================


@pytest.fixture
def sequence_n3_rule() -> str:
    """WCP-1 Sequence pattern rule in N3.

    Models sequential execution: if task A completes, start task B.

    Returns
    -------
    str
        N3 rule encoding sequence control flow.

    Notes
    -----
    Uses KGCL workflow ontology predicates:
    - wf:completedTask
    - wf:enablesTask
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

{
    ?workflow wf:completedTask ?taskA .
    ?taskA wf:enablesTask ?taskB .
}
=>
{
    ?workflow wf:readyTask ?taskB .
} .
"""


@pytest.fixture
def parallel_split_n3_rule() -> str:
    """WCP-2 Parallel Split pattern rule in N3.

    Models AND-split: if task A completes, start all parallel tasks.

    Returns
    -------
    str
        N3 rule encoding parallel split control flow.

    Notes
    -----
    Enables all tasks in a parallel block simultaneously.
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .

{
    ?workflow wf:completedTask ?taskA .
    ?taskA wf:parallelSplit ?block .
    ?block wf:containsTask ?taskB .
}
=>
{
    ?workflow wf:readyTask ?taskB .
} .
"""


@pytest.fixture
def synchronization_n3_rule() -> str:
    """WCP-3 Synchronization pattern rule in N3.

    Models AND-join: start task C only when all parallel tasks complete.

    Returns
    -------
    str
        N3 rule encoding synchronization control flow.

    Notes
    -----
    Requires counting completed tasks in parallel block.
    Uses aggregation via N3 list processing.
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

{
    ?workflow wf:synchronizationPoint ?sync .
    ?sync wf:waitingFor ?tasks .
    ?tasks list:length ?expectedCount .

    # Collect completed tasks
    ( ?x { ?workflow wf:completedTask ?x . ?tasks list:member ?x . } ?completed ) .
    ?completed list:length ?expectedCount .

    ?sync wf:enablesTask ?taskC .
}
=>
{
    ?workflow wf:readyTask ?taskC .
} .
"""


@pytest.fixture
def xor_split_n3_rule() -> str:
    """WCP-4 Exclusive Choice (XOR Split) pattern rule in N3.

    Models conditional branching: start task B OR C based on predicate.

    Returns
    -------
    str
        N3 rule encoding XOR split control flow.

    Notes
    -----
    Uses wf:condition to evaluate which branch to take.
    Only one outgoing task becomes ready.
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .

{
    ?workflow wf:completedTask ?taskA .
    ?taskA wf:xorSplit ?choice .
    ?choice wf:condition ?condition .
    ?choice wf:branch ?branch .
    ?branch wf:predicate ?condition .
    ?branch wf:enablesTask ?taskB .
}
=>
{
    ?workflow wf:readyTask ?taskB .
} .
"""


@pytest.fixture
def xor_join_n3_rule() -> str:
    """WCP-5 Simple Merge (XOR Join) pattern rule in N3.

    Models convergence: start task D when any of tasks B or C complete.

    Returns
    -------
    str
        N3 rule encoding XOR join control flow.

    Notes
    -----
    First completed task triggers downstream task.
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .

{
    ?workflow wf:completedTask ?taskB .
    ?taskB wf:mergePoint ?merge .
    ?merge wf:enablesTask ?taskD .
}
=>
{
    ?workflow wf:readyTask ?taskD .
} .
"""


@pytest.fixture
def multi_choice_n3_rule() -> str:
    """WCP-6 Multi-Choice pattern rule in N3.

    Models OR-split: start subset of tasks based on multiple conditions.

    Returns
    -------
    str
        N3 rule encoding multi-choice control flow.

    Notes
    -----
    Evaluates multiple predicates independently.
    Each satisfied condition enables its corresponding task.
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .

{
    ?workflow wf:completedTask ?taskA .
    ?taskA wf:multiChoice ?choice .
    ?choice wf:option ?option .
    ?option wf:condition ?condition .
    ?option wf:enablesTask ?task .
    # Python evaluator checks condition
}
=>
{
    ?workflow wf:readyTask ?task .
} .
"""


# =============================================================================
# Workflow Topology Fixtures (RDF Graphs)
# =============================================================================


@pytest.fixture
def simple_sequence_topology() -> str:
    """Linear workflow: A -> B -> C.

    Returns
    -------
    str
        Turtle RDF encoding workflow structure.

    Notes
    -----
    Three tasks in strict sequence.
    Used to test WCP-1 (Sequence) pattern.
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .
@prefix ex: <http://example.org/workflow#> .

ex:workflow1 a wf:Workflow ;
    wf:startTask ex:taskA ;
    wf:task ex:taskA, ex:taskB, ex:taskC .

ex:taskA a wf:Task ;
    wf:name "Task A" ;
    wf:enablesTask ex:taskB .

ex:taskB a wf:Task ;
    wf:name "Task B" ;
    wf:enablesTask ex:taskC .

ex:taskC a wf:Task ;
    wf:name "Task C" .
"""


@pytest.fixture
def parallel_split_topology() -> str:
    """Parallel workflow: A -> {B, C} -> D.

    Returns
    -------
    str
        Turtle RDF encoding parallel split/join structure.

    Notes
    -----
    Task A splits into B and C (parallel).
    Task D synchronizes after both B and C complete.
    Tests WCP-2 (Parallel Split) and WCP-3 (Synchronization).
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .
@prefix ex: <http://example.org/workflow#> .

ex:workflow2 a wf:Workflow ;
    wf:startTask ex:taskA ;
    wf:task ex:taskA, ex:taskB, ex:taskC, ex:taskD .

ex:taskA a wf:Task ;
    wf:name "Task A" ;
    wf:parallelSplit ex:parallelBlock1 .

ex:parallelBlock1 a wf:ParallelBlock ;
    wf:containsTask ex:taskB, ex:taskC .

ex:taskB a wf:Task ;
    wf:name "Task B" .

ex:taskC a wf:Task ;
    wf:name "Task C" .

ex:syncPoint1 a wf:SynchronizationPoint ;
    wf:waitingFor ( ex:taskB ex:taskC ) ;
    wf:enablesTask ex:taskD .

ex:taskD a wf:Task ;
    wf:name "Task D" .
"""


@pytest.fixture
def xor_split_topology() -> str:
    """Exclusive choice workflow: A -> (B OR C) -> D.

    Returns
    -------
    str
        Turtle RDF encoding XOR split/join structure.

    Notes
    -----
    Task A branches to B or C based on condition.
    Task D merges after either B or C completes.
    Tests WCP-4 (XOR Split) and WCP-5 (XOR Join).
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .
@prefix ex: <http://example.org/workflow#> .

ex:workflow3 a wf:Workflow ;
    wf:startTask ex:taskA ;
    wf:task ex:taskA, ex:taskB, ex:taskC, ex:taskD .

ex:taskA a wf:Task ;
    wf:name "Task A" ;
    wf:xorSplit ex:choice1 .

ex:choice1 a wf:ExclusiveChoice ;
    wf:branch ex:branchB, ex:branchC .

ex:branchB a wf:Branch ;
    wf:predicate "amount > 1000" ;
    wf:enablesTask ex:taskB .

ex:branchC a wf:Branch ;
    wf:predicate "amount <= 1000" ;
    wf:enablesTask ex:taskC .

ex:taskB a wf:Task ;
    wf:name "Task B (High Value)" ;
    wf:mergePoint ex:merge1 .

ex:taskC a wf:Task ;
    wf:name "Task C (Low Value)" ;
    wf:mergePoint ex:merge1 .

ex:merge1 a wf:MergePoint ;
    wf:enablesTask ex:taskD .

ex:taskD a wf:Task ;
    wf:name "Task D" .
"""


@pytest.fixture
def multi_choice_topology() -> str:
    """OR-split workflow: A -> {B?, C?, D?} based on conditions.

    Returns
    -------
    str
        Turtle RDF encoding multi-choice structure.

    Notes
    -----
    Task A evaluates multiple conditions.
    Each satisfied condition enables corresponding task.
    Tests WCP-6 (Multi-Choice) pattern.
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .
@prefix ex: <http://example.org/workflow#> .

ex:workflow4 a wf:Workflow ;
    wf:startTask ex:taskA ;
    wf:task ex:taskA, ex:taskB, ex:taskC, ex:taskD .

ex:taskA a wf:Task ;
    wf:name "Task A" ;
    wf:multiChoice ex:orSplit1 .

ex:orSplit1 a wf:MultiChoice ;
    wf:option ex:optionB, ex:optionC, ex:optionD .

ex:optionB a wf:ChoiceOption ;
    wf:condition "requires_approval" ;
    wf:enablesTask ex:taskB .

ex:optionC a wf:ChoiceOption ;
    wf:condition "requires_notification" ;
    wf:enablesTask ex:taskC .

ex:optionD a wf:ChoiceOption ;
    wf:condition "requires_audit" ;
    wf:enablesTask ex:taskD .

ex:taskB a wf:Task ;
    wf:name "Approval Task" .

ex:taskC a wf:Task ;
    wf:name "Notification Task" .

ex:taskD a wf:Task ;
    wf:name "Audit Task" .
"""


@pytest.fixture
def loop_topology() -> str:
    """Loop workflow: A -> B -> C -> (back to B if condition).

    Returns
    -------
    str
        Turtle RDF encoding loop structure.

    Notes
    -----
    Task C can loop back to B based on predicate.
    Tests cycle handling in hybrid engine.
    """
    return """
@prefix wf: <http://kgcl.io/workflow#> .
@prefix ex: <http://example.org/workflow#> .

ex:workflow5 a wf:Workflow ;
    wf:startTask ex:taskA ;
    wf:task ex:taskA, ex:taskB, ex:taskC .

ex:taskA a wf:Task ;
    wf:name "Task A" ;
    wf:enablesTask ex:taskB .

ex:taskB a wf:Task ;
    wf:name "Task B (Loop Body)" ;
    wf:enablesTask ex:taskC .

ex:taskC a wf:Task ;
    wf:name "Task C (Loop Condition)" ;
    wf:xorSplit ex:loopChoice .

ex:loopChoice a wf:ExclusiveChoice ;
    wf:branch ex:loopBack, ex:loopExit .

ex:loopBack a wf:Branch ;
    wf:predicate "iterations < max_iterations" ;
    wf:enablesTask ex:taskB .

ex:loopExit a wf:Branch ;
    wf:predicate "iterations >= max_iterations" ;
    wf:terminates ex:workflow5 .
"""


# =============================================================================
# RDF Store Fixtures (Oxigraph)
# =============================================================================


@pytest.fixture
def empty_store() -> Store:
    """Empty Oxigraph in-memory store.

    Returns
    -------
    Store
        Fresh Oxigraph store with no triples.

    Notes
    -----
    Use for building graphs from scratch in tests.
    """
    return Store()


@pytest.fixture
def store_with_sequence(empty_store: Store, simple_sequence_topology: str) -> Store:
    """Oxigraph store loaded with simple sequence topology.

    Parameters
    ----------
    empty_store : Store
        Empty store fixture.
    simple_sequence_topology : str
        Sequence workflow Turtle.

    Returns
    -------
    Store
        Store containing A -> B -> C workflow.

    Notes
    -----
    Preloaded for testing sequence pattern execution.
    """
    empty_store.load(simple_sequence_topology.encode(), mime_type="text/turtle")
    return empty_store


@pytest.fixture
def store_with_parallel(empty_store: Store, parallel_split_topology: str) -> Store:
    """Oxigraph store loaded with parallel split/join topology.

    Parameters
    ----------
    empty_store : Store
        Empty store fixture.
    parallel_split_topology : str
        Parallel workflow Turtle.

    Returns
    -------
    Store
        Store containing A -> {B, C} -> D workflow.

    Notes
    -----
    Preloaded for testing parallel patterns.
    """
    empty_store.load(parallel_split_topology.encode(), mime_type="text/turtle")
    return empty_store


@pytest.fixture
def store_with_xor(empty_store: Store, xor_split_topology: str) -> Store:
    """Oxigraph store loaded with XOR split/join topology.

    Parameters
    ----------
    empty_store : Store
        Empty store fixture.
    xor_split_topology : str
        XOR workflow Turtle.

    Returns
    -------
    Store
        Store containing A -> (B OR C) -> D workflow.

    Notes
    -----
    Preloaded for testing exclusive choice patterns.
    """
    empty_store.load(xor_split_topology.encode(), mime_type="text/turtle")
    return empty_store


# =============================================================================
# Hybrid Engine Fixtures (Placeholder - will be implemented)
# =============================================================================


@pytest.fixture
def empty_engine() -> Any:
    """Empty HybridEngine instance.

    Returns
    -------
    HybridEngine
        Fresh engine with no rules or topology loaded.

    Notes
    -----
    Placeholder until HybridEngine is implemented.
    Use for testing engine initialization.
    """
    # TODO: Replace with actual HybridEngine after implementation
    # return HybridEngine()
    return None


@pytest.fixture
def loaded_engine(
    sequence_n3_rule: str,
    simple_sequence_topology: str,
) -> Any:
    """HybridEngine loaded with sequence rule and topology.

    Parameters
    ----------
    sequence_n3_rule : str
        WCP-1 sequence N3 rule.
    simple_sequence_topology : str
        A -> B -> C workflow Turtle.

    Returns
    -------
    HybridEngine
        Engine ready to execute sequence workflow.

    Notes
    -----
    Placeholder until HybridEngine is implemented.
    Preloaded for testing execution without setup overhead.
    """
    # TODO: Replace with actual HybridEngine after implementation
    # engine = HybridEngine()
    # engine.load_rule(sequence_n3_rule)
    # engine.load_topology(simple_sequence_topology)
    # return engine
    return None


@pytest.fixture
def parallel_engine(
    parallel_split_n3_rule: str,
    synchronization_n3_rule: str,
    parallel_split_topology: str,
) -> Any:
    """HybridEngine loaded with parallel split/join rules.

    Parameters
    ----------
    parallel_split_n3_rule : str
        WCP-2 parallel split N3 rule.
    synchronization_n3_rule : str
        WCP-3 synchronization N3 rule.
    parallel_split_topology : str
        A -> {B, C} -> D workflow Turtle.

    Returns
    -------
    HybridEngine
        Engine ready to execute parallel workflows.

    Notes
    -----
    Placeholder until HybridEngine is implemented.
    """
    # TODO: Replace with actual HybridEngine after implementation
    # engine = HybridEngine()
    # engine.load_rule(parallel_split_n3_rule)
    # engine.load_rule(synchronization_n3_rule)
    # engine.load_topology(parallel_split_topology)
    # return engine
    return None


@pytest.fixture
def xor_engine(
    xor_split_n3_rule: str,
    xor_join_n3_rule: str,
    xor_split_topology: str,
) -> Any:
    """HybridEngine loaded with XOR split/join rules.

    Parameters
    ----------
    xor_split_n3_rule : str
        WCP-4 XOR split N3 rule.
    xor_join_n3_rule : str
        WCP-5 XOR join N3 rule.
    xor_split_topology : str
        A -> (B OR C) -> D workflow Turtle.

    Returns
    -------
    HybridEngine
        Engine ready to execute exclusive choice workflows.

    Notes
    -----
    Placeholder until HybridEngine is implemented.
    """
    # TODO: Replace with actual HybridEngine after implementation
    # engine = HybridEngine()
    # engine.load_rule(xor_split_n3_rule)
    # engine.load_rule(xor_join_n3_rule)
    # engine.load_topology(xor_split_topology)
    # return engine
    return None


# =============================================================================
# Execution Context Fixtures
# =============================================================================


@pytest.fixture
def execution_context() -> dict[str, Any]:
    """Default execution context with workflow variables.

    Returns
    -------
    dict[str, Any]
        Context dictionary with runtime variables.

    Notes
    -----
    Used to evaluate predicates in conditional branches.
    Contains variables like 'amount', 'user', 'priority', etc.
    """
    return {
        "amount": 500,
        "user": "test_user",
        "priority": "high",
        "requires_approval": True,
        "requires_notification": False,
        "requires_audit": True,
        "iterations": 0,
        "max_iterations": 3,
    }


@pytest.fixture
def high_value_context() -> dict[str, Any]:
    """Execution context for high-value transactions.

    Returns
    -------
    dict[str, Any]
        Context with amount > 1000 to trigger high-value branch.

    Notes
    -----
    Used to test XOR split with high-value condition.
    """
    return {
        "amount": 2500,
        "requires_approval": True,
        "requires_notification": True,
        "requires_audit": True,
    }


@pytest.fixture
def low_value_context() -> dict[str, Any]:
    """Execution context for low-value transactions.

    Returns
    -------
    dict[str, Any]
        Context with amount <= 1000 to trigger low-value branch.

    Notes
    -----
    Used to test XOR split with low-value condition.
    """
    return {
        "amount": 250,
        "requires_approval": False,
        "requires_notification": True,
        "requires_audit": False,
    }


# =============================================================================
# Performance Testing Fixtures
# =============================================================================


@pytest.fixture
def large_workflow_topology() -> str:
    """Large workflow with 100 tasks for performance testing.

    Returns
    -------
    str
        Turtle RDF encoding 100-task workflow.

    Notes
    -----
    Linear chain of 100 tasks for scalability testing.
    Target: p99 < 100ms for full execution.
    """
    tasks = []
    for i in range(100):
        task_name = f"task{i:03d}"
        next_task = f"task{i+1:03d}" if i < 99 else None

        task_def = f"""
ex:{task_name} a wf:Task ;
    wf:name "Task {i}" """

        if next_task:
            task_def += f";\n    wf:enablesTask ex:{next_task} "

        task_def += "."
        tasks.append(task_def)

    workflow = f"""
@prefix wf: <http://kgcl.io/workflow#> .
@prefix ex: <http://example.org/workflow#> .

ex:large_workflow a wf:Workflow ;
    wf:startTask ex:task000 ;
    wf:task {', '.join(f'ex:task{i:03d}' for i in range(100))} .

{chr(10).join(tasks)}
"""
    return workflow


@pytest.fixture
def stress_test_context() -> dict[str, Any]:
    """Context for stress testing with many variables.

    Returns
    -------
    dict[str, Any]
        Context with 1000 variables.

    Notes
    -----
    Tests predicate evaluation performance with large contexts.
    """
    return {f"var_{i}": i for i in range(1000)}
