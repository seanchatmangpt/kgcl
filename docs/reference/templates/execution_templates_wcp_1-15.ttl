@prefix kgc: <http://bitflow.ai/ontology/kgc/v3#> .
@prefix yawl: <http://www.yawlfoundation.org/yawlschema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# =============================================================================
# EXECUTION TEMPLATES FOR WCP 1-15
# =============================================================================
#
# PURPOSE: SPARQL CONSTRUCT templates that are EXECUTED directly by engine
# ARCHITECTURE: RDF-only execution - templates replace Python if/else logic
#
# TEMPLATE FORMAT:
# - Each pattern has kgc:executionTemplate property
# - Template is SPARQL CONSTRUCT query string
# - Bindings:
#   ?subject = Current task being executed
#   ?txId = Transaction ID for this execution
#   ?caseData = Case-level data graph
#
# EXECUTION MODEL:
# 1. Engine detects pattern match on ?subject
# 2. Retrieves kgc:executionTemplate from pattern mapping
# 3. Executes CONSTRUCT with bindings
# 4. Inserts resulting triples into execution graph
# 5. No Python interpretation required
#
# =============================================================================

# =============================================================================
# PROPERTY DEFINITION: kgc:executionTemplate
# =============================================================================

kgc:executionTemplate a rdf:Property ;
    rdfs:label "execution template"@en ;
    rdfs:domain kgc:PatternMapping ;
    rdfs:range xsd:string ;
    rdfs:comment "SPARQL CONSTRUCT template executed directly for this pattern. Template receives ?subject (current task), ?txId (transaction ID), and ?caseData (case graph) as bindings."@en .

# =============================================================================
# BASIC CONTROL FLOW PATTERNS (WCP 1-5)
# =============================================================================

# WCP-1: Sequence
# VERB: Transmute (move token from A to B)
# SEMANTICS: Single successor, simple token transfer
kgc:WCP1_Sequence kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Remove token from current task
    ?subject kgc:hasToken false .
    ?subject kgc:completedAt ?timestamp .

    # Create token on next task
    ?next kgc:hasToken true .
    ?next kgc:status "Active" .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Transmute ;
        kgc:parametersUsed "none" ;
        kgc:sourceTask ?subject ;
        kgc:targetTask ?next ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Find single successor via flow
    ?subject yawl:flowsInto ?flow .
    ?flow yawl:nextElementRef ?next .

    # Generate timestamp
    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# WCP-2: Parallel Split (AND-split)
# VERB: Copy (clone token to ALL successors)
# SEMANTICS: Cardinality = topology (all outgoing flows)
kgc:WCP2_ParallelSplit kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Remove token from current task
    ?subject kgc:hasToken false .
    ?subject kgc:completedAt ?timestamp .

    # Clone token to ALL successors
    ?successor kgc:hasToken true .
    ?successor kgc:status "Active" .
    ?successor kgc:parentExecution ?subject .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Copy ;
        kgc:parametersUsed "cardinality=topology" ;
        kgc:sourceTask ?subject ;
        kgc:targetTask ?successor ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Find ALL successors
    ?subject yawl:flowsInto ?flow .
    ?flow yawl:nextElementRef ?successor .

    # Verify this is AND-split
    ?subject yawl:hasSplit yawl:ControlTypeAnd .

    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# WCP-3: Synchronization (AND-join)
# VERB: Await (wait for ALL incoming tokens)
# SEMANTICS: Threshold = all, fires when count(active predecessors) = count(predecessors)
kgc:WCP3_Synchronization kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Mark this join as complete (only if ALL predecessors have tokens)
    ?subject kgc:hasToken true .
    ?subject kgc:status "Active" .

    # Consume tokens from predecessors
    ?predecessor kgc:hasToken false .
    ?predecessor kgc:consumedBy ?subject .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Await ;
        kgc:parametersUsed "threshold=all,completionStrategy=waitAll" ;
        kgc:sourceTask ?predecessor ;
        kgc:targetTask ?subject ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Find ALL predecessors
    {
        SELECT ?subject (COUNT(?predecessor) AS ?totalPredecessors)
        WHERE {
            ?flow yawl:nextElementRef ?subject .
            ?predecessor yawl:flowsInto ?flow .
        }
        GROUP BY ?subject
    }

    # Count predecessors with tokens
    {
        SELECT ?subject (COUNT(?predecessor) AS ?activePredecessors)
        WHERE {
            ?flow yawl:nextElementRef ?subject .
            ?predecessor yawl:flowsInto ?flow .
            ?predecessor kgc:hasToken true .
        }
        GROUP BY ?subject
    }

    # Fire only when ALL have tokens
    FILTER(?activePredecessors = ?totalPredecessors)

    # Get predecessors for token consumption
    ?flow yawl:nextElementRef ?subject .
    ?predecessor yawl:flowsInto ?flow .
    ?predecessor kgc:hasToken true .

    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# WCP-4: Exclusive Choice (XOR-split)
# VERB: Filter (select EXACTLY ONE successor based on predicate)
# SEMANTICS: selectionMode = exactlyOne
kgc:WCP4_ExclusiveChoice kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Remove token from current task
    ?subject kgc:hasToken false .
    ?subject kgc:completedAt ?timestamp .

    # Create token on EXACTLY ONE successor (first matching predicate)
    ?selected kgc:hasToken true .
    ?selected kgc:status "Active" .

    # Mark non-selected paths as voided
    ?notSelected kgc:status "Voided" .
    ?notSelected kgc:voidedAt ?timestamp .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Filter ;
        kgc:parametersUsed "selectionMode=exactlyOne" ;
        kgc:sourceTask ?subject ;
        kgc:targetTask ?selected ;
        kgc:predicateUsed ?predicate ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Find successor with TRUE predicate (LIMIT 1 for exactlyOne semantics)
    {
        SELECT ?subject ?selected ?predicate
        WHERE {
            ?subject yawl:flowsInto ?flow .
            ?flow yawl:nextElementRef ?selected .
            ?flow yawl:predicate ?predicate .

            # Evaluate predicate against case data
            # NOTE: Predicate evaluation would use ASK query in real implementation
            # For template, we assume ?predicate evaluates to true
            FILTER(true)  # Placeholder for actual predicate evaluation
        }
        LIMIT 1
    }

    # Find non-selected successors for voiding
    OPTIONAL {
        ?subject yawl:flowsInto ?otherFlow .
        ?otherFlow yawl:nextElementRef ?notSelected .
        FILTER(?notSelected != ?selected)
    }

    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# WCP-5: Simple Merge (XOR-join)
# VERB: Transmute (first arrival continues, no synchronization)
# SEMANTICS: No threshold, any incoming token triggers
kgc:WCP5_SimpleMerge kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Consume token from ANY predecessor (first arrival)
    ?predecessor kgc:hasToken false .
    ?predecessor kgc:completedAt ?timestamp .

    # Activate this task
    ?subject kgc:hasToken true .
    ?subject kgc:status "Active" .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Transmute ;
        kgc:parametersUsed "none" ;
        kgc:sourceTask ?predecessor ;
        kgc:targetTask ?subject ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Find ANY predecessor with token (LIMIT 1 for first arrival)
    {
        SELECT ?subject ?predecessor
        WHERE {
            ?flow yawl:nextElementRef ?subject .
            ?predecessor yawl:flowsInto ?flow .
            ?predecessor kgc:hasToken true .
        }
        LIMIT 1
    }

    # Verify this is XOR-join
    ?subject yawl:hasJoin yawl:ControlTypeXor .

    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# =============================================================================
# ADVANCED BRANCHING PATTERNS (WCP 6-9)
# =============================================================================

# WCP-6: Multi-Choice (OR-split)
# VERB: Filter (select ONE OR MORE successors based on predicates)
# SEMANTICS: selectionMode = oneOrMore
kgc:WCP6_MultiChoice kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Remove token from current task
    ?subject kgc:hasToken false .
    ?subject kgc:completedAt ?timestamp .

    # Create tokens on ALL matching successors
    ?selected kgc:hasToken true .
    ?selected kgc:status "Active" .
    ?selected kgc:parentExecution ?subject .

    # Mark non-selected paths as voided
    ?notSelected kgc:status "Voided" .
    ?notSelected kgc:voidedAt ?timestamp .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Filter ;
        kgc:parametersUsed "selectionMode=oneOrMore" ;
        kgc:sourceTask ?subject ;
        kgc:targetTask ?selected ;
        kgc:predicateUsed ?predicate ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Find ALL successors with TRUE predicates
    {
        SELECT ?subject ?selected ?predicate
        WHERE {
            ?subject yawl:flowsInto ?flow .
            ?flow yawl:nextElementRef ?selected .
            ?flow yawl:predicate ?predicate .

            # Evaluate predicate against case data
            # NOTE: Real implementation would evaluate ?predicate
            FILTER(true)  # Placeholder
        }
    }

    # Find non-selected successors for voiding
    OPTIONAL {
        ?subject yawl:flowsInto ?otherFlow .
        ?otherFlow yawl:nextElementRef ?notSelected .
        FILTER NOT EXISTS {
            ?subject yawl:flowsInto ?matchFlow .
            ?matchFlow yawl:nextElementRef ?selected .
            FILTER(?notSelected = ?selected)
        }
    }

    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# WCP-7: Structured Synchronizing Merge (OR-join)
# VERB: Await (wait for ALL ACTIVE predecessors)
# SEMANTICS: threshold = active, completionStrategy = waitActive
kgc:WCP7_StructuredSyncMerge kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Mark this join as complete (only if ALL ACTIVE predecessors have tokens)
    ?subject kgc:hasToken true .
    ?subject kgc:status "Active" .

    # Consume tokens from active predecessors
    ?predecessor kgc:hasToken false .
    ?predecessor kgc:consumedBy ?subject .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Await ;
        kgc:parametersUsed "threshold=active,completionStrategy=waitActive" ;
        kgc:sourceTask ?predecessor ;
        kgc:targetTask ?subject ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Find ALL active (not voided) predecessors
    {
        SELECT ?subject (COUNT(?predecessor) AS ?activePredecessors)
        WHERE {
            ?flow yawl:nextElementRef ?subject .
            ?predecessor yawl:flowsInto ?flow .
            FILTER NOT EXISTS { ?predecessor kgc:status "Voided" }
        }
        GROUP BY ?subject
    }

    # Count active predecessors with tokens
    {
        SELECT ?subject (COUNT(?predecessor) AS ?readyPredecessors)
        WHERE {
            ?flow yawl:nextElementRef ?subject .
            ?predecessor yawl:flowsInto ?flow .
            ?predecessor kgc:hasToken true .
            FILTER NOT EXISTS { ?predecessor kgc:status "Voided" }
        }
        GROUP BY ?subject
    }

    # Fire when ALL active have tokens
    FILTER(?readyPredecessors = ?activePredecessors)

    # Get active predecessors for token consumption
    ?flow yawl:nextElementRef ?subject .
    ?predecessor yawl:flowsInto ?flow .
    ?predecessor kgc:hasToken true .
    FILTER NOT EXISTS { ?predecessor kgc:status "Voided" }

    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# WCP-8: Multi-Merge
# VERB: Transmute (each arrival triggers successor independently)
# SEMANTICS: No synchronization, stateless
kgc:WCP8_MultiMerge kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Consume token from ANY predecessor (no synchronization)
    ?predecessor kgc:hasToken false .
    ?predecessor kgc:completedAt ?timestamp .

    # Create NEW token on successor for EACH arrival
    ?successor kgc:hasToken true .
    ?successor kgc:status "Active" .
    ?successor kgc:parentExecution ?predecessor .
    ?successor kgc:instanceId ?instanceId .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Transmute ;
        kgc:parametersUsed "multiMerge=true" ;
        kgc:sourceTask ?predecessor ;
        kgc:targetTask ?successor ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Process EACH predecessor with token independently
    ?flow yawl:nextElementRef ?subject .
    ?predecessor yawl:flowsInto ?flow .
    ?predecessor kgc:hasToken true .

    # Find successor
    ?subject yawl:flowsInto ?outFlow .
    ?outFlow yawl:nextElementRef ?successor .

    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "instance-", STR(?txId), "-", STR(?predecessor))) AS ?instanceId)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# WCP-9: Structured Discriminator
# VERB: Await (fire on FIRST arrival, reset after)
# SEMANTICS: threshold = 1, completionStrategy = waitFirst, resetOnFire = true
kgc:WCP9_Discriminator kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Consume token from first arrival
    ?firstPredecessor kgc:hasToken false .
    ?firstPredecessor kgc:completedAt ?timestamp .

    # Activate successor
    ?subject kgc:hasToken true .
    ?subject kgc:status "Active" .

    # Mark join state as fired (for reset tracking)
    ?subject kgc:discriminatorFired true .
    ?subject kgc:discriminatorFiredAt ?timestamp .

    # Ignore subsequent arrivals (they remain active but don't trigger)
    ?otherPredecessor kgc:status "Ignored" .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Await ;
        kgc:parametersUsed "threshold=1,completionStrategy=waitFirst,resetOnFire=true" ;
        kgc:sourceTask ?firstPredecessor ;
        kgc:targetTask ?subject ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Only fire if not already fired
    FILTER NOT EXISTS { ?subject kgc:discriminatorFired true }

    # Get FIRST predecessor with token
    {
        SELECT ?subject ?firstPredecessor
        WHERE {
            ?flow yawl:nextElementRef ?subject .
            ?predecessor yawl:flowsInto ?flow .
            ?predecessor kgc:hasToken true .
        }
        ORDER BY ?predecessor
        LIMIT 1
    }

    # Get other predecessors for ignoring
    OPTIONAL {
        ?otherFlow yawl:nextElementRef ?subject .
        ?otherPredecessor yawl:flowsInto ?otherFlow .
        ?otherPredecessor kgc:hasToken true .
        FILTER(?otherPredecessor != ?firstPredecessor)
    }

    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# =============================================================================
# MULTIPLE INSTANCE PATTERNS (WCP 12-15)
# =============================================================================

# WCP-12: MI without Synchronization
# VERB: Copy (create N dynamic instances, no sync on completion)
# SEMANTICS: cardinality = dynamic, instanceBinding = data
kgc:WCP12_MINoSync kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Remove token from MI task launcher
    ?subject kgc:hasToken false .
    ?subject kgc:completedAt ?timestamp .

    # Create instance for EACH data item
    ?instance kgc:hasToken true .
    ?instance kgc:status "Active" .
    ?instance kgc:instanceId ?instanceId .
    ?instance kgc:parentTask ?subject .
    ?instance kgc:dataBinding ?dataItem .

    # NO synchronization required (fire-and-forget)
    ?instance kgc:requiresSync false .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Copy ;
        kgc:parametersUsed "cardinality=dynamic,instanceBinding=data,sync=false" ;
        kgc:sourceTask ?subject ;
        kgc:targetTask ?instance ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Get MI input data collection
    ?subject yawl:miDataInput ?inputVar .
    ?caseData ?inputVar ?dataCollection .

    # Create instance for each item in collection
    ?dataCollection rdf:rest*/rdf:first ?dataItem .

    # Generate instance task
    BIND(IRI(CONCAT(STR(?subject), "-instance-", MD5(STR(?dataItem)))) AS ?instance)
    BIND(MD5(STR(?dataItem)) AS ?instanceId)
    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# WCP-13: MI with Design-Time Knowledge
# VERB: Copy (create N static instances) + Await (sync all)
# SEMANTICS: cardinality = static, instanceBinding = index
kgc:WCP13_MIDesignTime kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Remove token from MI task launcher
    ?subject kgc:hasToken false .
    ?subject kgc:completedAt ?timestamp .

    # Create N instances (N known at design time)
    ?instance kgc:hasToken true .
    ?instance kgc:status "Active" .
    ?instance kgc:instanceId ?instanceId .
    ?instance kgc:instanceIndex ?index .
    ?instance kgc:parentTask ?subject .

    # Synchronization required for ALL instances
    ?instance kgc:requiresSync true .
    ?subject kgc:miTotalInstances ?maxInstances .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Copy ;
        kgc:parametersUsed "cardinality=static,instanceBinding=index,sync=true" ;
        kgc:sourceTask ?subject ;
        kgc:targetTask ?instance ;
        kgc:instanceCount ?maxInstances ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Get static cardinality (min = max at design time)
    ?subject yawl:minimum ?minInstances .
    ?subject yawl:maximum ?maxInstances .
    FILTER(?minInstances = ?maxInstances)

    # Generate instances 0 to N-1
    # NOTE: SPARQL doesn't have native loops, so this uses VALUES binding
    # Real implementation would use custom function or SPARQL 1.1 path expressions
    VALUES ?index { 0 1 2 3 4 5 6 7 8 9 }
    FILTER(?index < ?maxInstances)

    # Generate instance task
    BIND(IRI(CONCAT(STR(?subject), "-instance-", STR(?index))) AS ?instance)
    BIND(STR(?index) AS ?instanceId)
    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# WCP-14: MI with Runtime Knowledge
# VERB: Copy (create N dynamic instances from data) + Await (sync all)
# SEMANTICS: cardinality = dynamic, instanceBinding = data
kgc:WCP14_MIRuntime kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # Remove token from MI task launcher
    ?subject kgc:hasToken false .
    ?subject kgc:completedAt ?timestamp .

    # Create instance for EACH data item (N determined at runtime)
    ?instance kgc:hasToken true .
    ?instance kgc:status "Active" .
    ?instance kgc:instanceId ?instanceId .
    ?instance kgc:parentTask ?subject .
    ?instance kgc:dataBinding ?dataItem .

    # Synchronization required for ALL instances
    ?instance kgc:requiresSync true .
    ?subject kgc:miTotalInstances ?totalInstances .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Copy ;
        kgc:parametersUsed "cardinality=dynamic,instanceBinding=data,sync=true" ;
        kgc:sourceTask ?subject ;
        kgc:targetTask ?instance ;
        kgc:instanceCount ?totalInstances ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Get MI input data collection
    ?subject yawl:miDataInput ?inputVar .
    ?caseData ?inputVar ?dataCollection .

    # Create instance for each item in collection
    ?dataCollection rdf:rest*/rdf:first ?dataItem .

    # Count total instances for sync
    {
        SELECT (COUNT(?item) AS ?totalInstances)
        WHERE {
            ?caseData ?inputVar ?dataCollection .
            ?dataCollection rdf:rest*/rdf:first ?item .
        }
    }

    # Generate instance task
    BIND(IRI(CONCAT(STR(?subject), "-instance-", MD5(STR(?dataItem)))) AS ?instance)
    BIND(MD5(STR(?dataItem)) AS ?instanceId)
    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# WCP-15: MI without Prior Runtime Knowledge
# VERB: Copy (create instances incrementally during execution)
# SEMANTICS: cardinality = incremental, instanceBinding = data
kgc:WCP15_MINoPrior kgc:executionTemplate """
PREFIX kgc: <http://bitflow.ai/ontology/kgc/v3#>
PREFIX yawl: <http://www.yawlfoundation.org/yawlschema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

CONSTRUCT {
    # DO NOT consume token from MI task (it stays active)
    ?subject kgc:status "ActiveMI" .

    # Create NEW instance for incoming data item
    ?instance kgc:hasToken true .
    ?instance kgc:status "Active" .
    ?instance kgc:instanceId ?instanceId .
    ?instance kgc:parentTask ?subject .
    ?instance kgc:dataBinding ?dataItem .
    ?instance kgc:createdAt ?timestamp .

    # Incremental creation mode (can create more later)
    ?instance kgc:creationMode "incremental" .
    ?instance kgc:requiresSync false .

    # Provenance
    ?receipt a kgc:Receipt ;
        kgc:verbExecuted kgc:Copy ;
        kgc:parametersUsed "cardinality=incremental,instanceBinding=data,sync=false" ;
        kgc:sourceTask ?subject ;
        kgc:targetTask ?instance ;
        kgc:executedAt ?timestamp .
}
WHERE {
    # Get incoming data item (arrives during execution)
    ?subject yawl:miCreationMode yawl:Dynamic .
    ?subject kgc:pendingDataItems ?dataQueue .
    ?dataQueue rdf:first ?dataItem .

    # Verify instance doesn't already exist
    FILTER NOT EXISTS {
        ?existing kgc:parentTask ?subject ;
            kgc:dataBinding ?dataItem .
    }

    # Generate instance task
    BIND(IRI(CONCAT(STR(?subject), "-instance-", MD5(STR(?dataItem)), "-", STR(NOW()))) AS ?instance)
    BIND(MD5(CONCAT(STR(?dataItem), STR(NOW()))) AS ?instanceId)
    BIND(NOW() AS ?timestamp)
    BIND(IRI(CONCAT(STR(kgc:), "receipt-", STR(?txId))) AS ?receipt)
}
""" .

# =============================================================================
# USAGE NOTES
# =============================================================================
#
# EXECUTION FLOW:
# 1. Engine loads this ontology + pattern mappings
# 2. For active task ?subject with kgc:hasToken true:
#    - Match pattern via topology/properties
#    - Retrieve kgc:executionTemplate from mapping
#    - Bind ?subject, ?txId, ?caseData
#    - Execute CONSTRUCT query
#    - Insert results into execution graph
# 3. No Python if/else required - pure RDF execution
#
# PREDICATE EVALUATION:
# - Templates use FILTER(true) placeholder for predicates
# - Real implementation would evaluate yawl:predicate as nested ASK query
# - Could use SPARQL functions or external reasoner
#
# INSTANCE GENERATION:
# - Templates use VALUES or rdf:rest* for iteration
# - Real implementation might use custom SPARQL functions
# - Or preprocessing step to expand collections
#
# STATE MANAGEMENT:
# - Templates track execution state via kgc:hasToken, kgc:status
# - Provenance via kgc:Receipt instances
# - No external state store needed
#
# =============================================================================
