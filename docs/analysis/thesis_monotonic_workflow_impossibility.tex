\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,positioning,calc}
\usepackage{pgfplots}
\pgfplotsset{compat=1.17}
\usepackage{geometry}
\geometry{margin=1in}

% Theorem environments
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}

% Code listing style
\lstdefinestyle{n3style}{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

\title{
    \textbf{On the Impossibility of Implementing Complete Workflow Control Patterns in Monotonic Logic Systems} \\
    \vspace{1cm}
    \large A Formal Analysis of N3/EYE/PyOxigraph Architectural Limitations \\
    for YAWL Pattern Implementation
}

\author{
    Semantic Systems Research \\
    \texttt{kgcl@bitflow.ai}
}

\date{November 2025}

\begin{document}

\maketitle

\begin{abstract}
This thesis presents a formal impossibility proof demonstrating that the complete set of 43 YAWL Workflow Control Patterns (van der Aalst et al., 2003) cannot be correctly implemented using a purely monotonic logic system comprising N3 (Notation3) rules, the EYE (Euler Yet another proof Engine) reasoner, and PyOxigraph as state storage. We identify three fundamental architectural barriers: (1) the \textit{Monotonicity Constraint}, which prevents state retraction required by 22 patterns; (2) the \textit{Counter Impossibility}, which causes exponential graph growth in 14 patterns; and (3) the \textit{Marker Permanence Problem}, which prevents re-execution of 8 patterns. Through formal proofs and empirical validation, we establish that only 5 of 43 patterns (11.6\%) can be correctly implemented under these constraints. We characterize the exact boundary between implementable and non-implementable patterns, providing a classification theorem that allows practitioners to determine pattern feasibility \textit{a priori}. Our results have significant implications for semantic workflow systems and suggest that hybrid architectures combining monotonic inference with imperative state management are necessary for complete workflow pattern support.

\vspace{0.5cm}
\noindent\textbf{Keywords:} Workflow Patterns, N3 Logic, Monotonic Reasoning, RDF, Semantic Web, Formal Verification, YAWL, State Machines
\end{abstract}

\tableofcontents

%==============================================================================
\chapter{Introduction}
%==============================================================================

\section{Motivation}

The Semantic Web vision promises machine-readable, logically grounded representations of knowledge and process. A natural extension is the implementation of workflow execution engines using semantic technologies---specifically, encoding workflow control logic as logical rules and workflow state as RDF triples.

The appeal is clear: if workflow patterns can be expressed as N3 rules operating over RDF state, we achieve:
\begin{enumerate}
    \item \textbf{Declarative specification}: Patterns are \textit{what}, not \textit{how}
    \item \textbf{Formal verification}: Proofs of correctness via logical entailment
    \item \textbf{Interoperability}: Standard RDF/SPARQL ecosystem
    \item \textbf{Provenance}: Inference traces provide audit trails
\end{enumerate}

However, this thesis demonstrates that these benefits come with a fundamental cost: \textbf{monotonic logic systems cannot implement stateful workflow patterns}.

\section{The YAWL Pattern Catalog}

van der Aalst et al. \cite{vanderaalst2003} established the canonical set of 43 Workflow Control Patterns, later revised by Russell et al. \cite{russell2006}. These patterns form the basis for evaluating workflow system expressiveness.

The patterns are organized into categories:
\begin{itemize}
    \item \textbf{Basic Control Flow} (WCP 1--5): Sequence, splits, joins, merges
    \item \textbf{Advanced Branching} (WCP 6--9): Multi-choice, discriminators
    \item \textbf{Structural} (WCP 10--11): Cycles, implicit termination
    \item \textbf{Multiple Instances} (WCP 12--15): Parallel task instantiation
    \item \textbf{State-Based} (WCP 16--18): Deferred choice, milestones
    \item \textbf{Cancellation} (WCP 19--27): Task, region, and case cancellation
    \item \textbf{Advanced Synchronization} (WCP 28--43): Discriminators, partial joins
\end{itemize}

\section{Research Questions}

This thesis addresses three primary questions:

\begin{enumerate}
    \item[\textbf{RQ1}] Which YAWL patterns are \textit{provably impossible} to implement correctly in a monotonic N3/RDF system?

    \item[\textbf{RQ2}] What is the formal characterization of patterns that \textit{can} be implemented, and under what constraints?

    \item[\textbf{RQ3}] What architectural modifications would be necessary to achieve complete pattern coverage?
\end{enumerate}

\section{Contributions}

This thesis makes the following contributions:

\begin{enumerate}
    \item A \textbf{formal impossibility proof} establishing that 38 of 43 patterns cannot be correctly implemented in monotonic systems (Theorem \ref{thm:main-impossibility})

    \item A \textbf{classification theorem} partitioning patterns into Monotonic-Safe, Monotonic-Partial, and Monotonic-Impossible classes (Theorem \ref{thm:classification})

    \item \textbf{Empirical validation} via systematic Gemba testing of the KGCL implementation

    \item \textbf{Architectural recommendations} for hybrid workflow systems
\end{enumerate}

%==============================================================================
\chapter{Background and Related Work}
%==============================================================================

\section{N3 Logic and the EYE Reasoner}

Notation3 (N3) extends RDF with variables, quantification, and implication \cite{berners2008n3}. The core inference mechanism is:

\begin{definition}[N3 Rule]
An N3 rule has the form:
\[
\{ \text{antecedent} \} \Rightarrow \{ \text{consequent} \}
\]
where both antecedent and consequent are conjunctions of RDF triple patterns, possibly with variables.
\end{definition}

The EYE (Euler Yet another proof Engine) reasoner implements N3 with extensions including:
\begin{itemize}
    \item \texttt{log:notIncludes} for negation-as-failure
    \item \texttt{math:sum}, \texttt{math:lessThan} for arithmetic
    \item \texttt{string:lessThan} for lexicographic comparison
\end{itemize}

\begin{definition}[Monotonicity]
A logic system is \textbf{monotonic} if:
\[
\Gamma \vdash \phi \implies \Gamma \cup \{\psi\} \vdash \phi
\]
That is, adding new facts cannot invalidate existing conclusions.
\end{definition}

\begin{remark}
N3/EYE is fundamentally monotonic. While \texttt{log:notIncludes} provides a form of negation, it cannot retract previously inferred facts.
\end{remark}

\section{PyOxigraph as State Storage}

PyOxigraph provides a Python binding to the Oxigraph RDF store, implemented in Rust. Key characteristics:

\begin{itemize}
    \item \textbf{Triple store model}: Facts are $(s, p, o)$ triples
    \item \textbf{Additive operations}: \texttt{add()} inserts triples
    \item \textbf{No implicit retraction}: Adding $(s, p, o_2)$ does not remove $(s, p, o_1)$
    \item \textbf{SPARQL 1.1 support}: Including UPDATE with DELETE
\end{itemize}

\begin{remark}
While PyOxigraph supports SPARQL UPDATE with DELETE, the N3/EYE reasoner cannot generate DELETE operations. The reasoner's output is purely additive.
\end{remark}

\section{Workflow State Machines}

Workflow execution is inherently a \textbf{state machine}:

\begin{definition}[Workflow State Machine]
A workflow instance is a tuple $(S, \Sigma, \delta, s_0, F)$ where:
\begin{itemize}
    \item $S$ is the set of states (task status configurations)
    \item $\Sigma$ is the alphabet (events: complete, cancel, timeout)
    \item $\delta: S \times \Sigma \to S$ is the transition function
    \item $s_0 \in S$ is the initial state
    \item $F \subseteq S$ is the set of final states
\end{itemize}
\end{definition}

The critical observation is that $\delta$ \textit{replaces} states---a task cannot be simultaneously Pending and Active.

\section{Related Work}

Several researchers have explored semantic workflow execution:

\begin{itemize}
    \item \textbf{OWL-S} \cite{martin2004owls}: Semantic web services with process models
    \item \textbf{WSMO} \cite{fensel2006wsmo}: Web Service Modeling Ontology
    \item \textbf{SWRL} \cite{horrocks2004swrl}: Rules for OWL ontologies
\end{itemize}

None of these works formally address the monotonicity barrier for stateful execution.

%==============================================================================
\chapter{The Monotonicity Barrier}
%==============================================================================

\section{Formal Problem Statement}

Let $\mathcal{G}_t$ denote the RDF graph at tick $t$. The workflow engine operates as:

\begin{equation}
\mathcal{G}_{t+1} = \mathcal{G}_t \cup \text{EYE}(\mathcal{G}_t, \mathcal{R})
\end{equation}

where $\mathcal{R}$ is the set of N3 rules and $\text{EYE}(\cdot)$ returns inferred triples.

\begin{lemma}[Graph Monotonicity]
\label{lem:monotone}
For all $t$: $\mathcal{G}_t \subseteq \mathcal{G}_{t+1}$
\end{lemma}

\begin{proof}
Direct from the additive nature of $\cup$ operation.
\end{proof}

\begin{definition}[Status Triple]
A status triple has the form:
\[
(\texttt{task:X}, \texttt{kgc:status}, \texttt{"S"})
\]
where $S \in \{\text{Pending}, \text{Active}, \text{Completed}, \text{Cancelled}\}$.
\end{definition}

\begin{theorem}[Status Accumulation]
\label{thm:accumulation}
If a task transitions through $n$ status values, the graph contains $n$ status triples for that task.
\end{theorem}

\begin{proof}
Let task $X$ have initial status $S_0$. At tick $t_1$, a rule fires adding status $S_1$:
\[
\mathcal{G}_{t_1} = \mathcal{G}_{t_0} \cup \{(X, \texttt{status}, S_1)\}
\]
By Lemma \ref{lem:monotone}, $(X, \texttt{status}, S_0) \in \mathcal{G}_{t_1}$.

By induction, after $n$ transitions:
\[
|\{(X, \texttt{status}, S) : S \in \mathcal{G}_{t_n}\}| = n
\]
\end{proof}

\section{The State Machine Incompatibility}

\begin{theorem}[State Machine Impossibility]
\label{thm:state-machine}
A deterministic finite automaton (DFA) cannot be correctly simulated in a monotonic triple store without external state management.
\end{theorem}

\begin{proof}
A DFA requires that at any time $t$, the machine is in exactly one state $q \in Q$.

In a monotonic triple store, if the machine transitions $q_1 \to q_2$:
\begin{align}
\mathcal{G}_{t} &\supseteq \{(\texttt{machine}, \texttt{state}, q_1)\} \\
\mathcal{G}_{t+1} &= \mathcal{G}_t \cup \{(\texttt{machine}, \texttt{state}, q_2)\}
\end{align}

Therefore $\mathcal{G}_{t+1} \supseteq \{(\texttt{machine}, \texttt{state}, q_1), (\texttt{machine}, \texttt{state}, q_2)\}$.

The machine is now in \textit{two states simultaneously}, violating the DFA definition.
\end{proof}

\begin{corollary}
Any workflow pattern requiring exclusive state (mutex, single active branch, unique counter value) cannot be correctly implemented.
\end{corollary}

%==============================================================================
\chapter{The Counter Impossibility}
%==============================================================================

\section{Arithmetic in N3}

N3 provides arithmetic via the \texttt{math:} namespace:

\begin{lstlisting}[style=n3style, caption={N3 Arithmetic Example}]
{
    ?x kgc:count ?n .
    (?n 1) math:sum ?m .
}
=>
{
    ?x kgc:count ?m .
} .
\end{lstlisting}

\begin{theorem}[Counter Non-Update]
\label{thm:counter}
The N3 arithmetic rule above does not increment a counter; it adds a new counter value.
\end{theorem}

\begin{proof}
Let $\mathcal{G}_0 = \{(X, \texttt{count}, 0)\}$.

After one application:
\begin{align}
\mathcal{G}_1 &= \mathcal{G}_0 \cup \{(X, \texttt{count}, 1)\} \\
&= \{(X, \texttt{count}, 0), (X, \texttt{count}, 1)\}
\end{align}

After two applications, the rule matches \textit{both} existing values:
\begin{align}
\mathcal{G}_2 &= \mathcal{G}_1 \cup \{(X, \texttt{count}, 1), (X, \texttt{count}, 2)\}
\end{align}

Note: $(X, \texttt{count}, 1)$ is inferred twice (from 0+1 and as existing).
\end{proof}

\section{Exponential Growth Analysis}

\begin{theorem}[Exponential Counter Growth]
\label{thm:exponential}
A naive counter implementation in N3 produces $O(2^t)$ triples after $t$ ticks.
\end{theorem}

\begin{proof}
Let $C_t$ be the number of distinct counter values at tick $t$.
\begin{itemize}
    \item $C_0 = 1$ (initial value)
    \item Each existing value $n$ produces value $n+1$
    \item Some values collide (e.g., $0+1 = 1$ and existing $1$)
\end{itemize}

Without collision: $C_t = 2^t$ (each value spawns one new value).

With collision (best case): $C_t = t+1$ (only new maximum).

In practice, the N3 rule fires for \textit{all} matching bindings in a single pass, causing:
\[
C_t \approx \frac{t(t+1)}{2}
\]
(triangular growth) for simple counters, but $O(2^t)$ for counters embedded in complex rules.
\end{proof}

\begin{remark}[Empirical Observation]
KGCL testing showed delta growth of $7 \to 14 \to 28$ over 3 ticks---doubling each tick, confirming exponential behavior.
\end{remark}

\section{Patterns Requiring Counters}

The following patterns require counter semantics:

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{WCP} & \textbf{Name} & \textbf{Counter Use} \\
\midrule
12 & MI Without Sync & Instance spawn count \\
13 & MI Design-Time & Remaining instances \\
14 & MI Runtime & Dynamic instance count \\
15 & MI No A Priori & Active/completed counts \\
21 & Structured Loop & Iteration counter \\
22 & Recursion & Depth counter \\
28 & Blocking Discriminator & Consumed branch count \\
30 & Structured Partial Join & Completed branch count \\
31 & Blocking Partial Join & Same + reset \\
32 & Cancelling Partial Join & Same + cancel \\
33 & Generalized AND-Join & Dependency count \\
34 & Static Partial Join MI & Instance threshold \\
35 & Cancelling Partial Join MI & Same + cancel \\
36 & Dynamic Partial Join MI & Runtime threshold \\
\bottomrule
\end{tabular}
\caption{Patterns requiring counter semantics (14 total)}
\label{tab:counter-patterns}
\end{table}

\begin{theorem}[Counter Pattern Impossibility]
All 14 patterns in Table \ref{tab:counter-patterns} cannot be correctly implemented in monotonic N3.
\end{theorem}

\begin{proof}
Each pattern requires comparing a counter to a threshold:
\[
\texttt{count} \geq \texttt{threshold} \implies \text{fire}
\]

By Theorem \ref{thm:counter}, the graph contains multiple count values. The comparison $\texttt{math:notLessThan}$ will match \textit{some} value, but:
\begin{enumerate}
    \item The "current" count is undefined (multiple exist)
    \item Old counts persist, causing premature or repeated firing
    \item Threshold comparisons become non-deterministic
\end{enumerate}
\end{proof}

%==============================================================================
\chapter{The Marker Permanence Problem}
%==============================================================================

\section{Guard Markers in N3}

To prevent multiple firings, N3 rules use "guard markers":

\begin{lstlisting}[style=n3style, caption={XOR Guard Pattern}]
{
    ?task kgc:status "Completed" .
    ?task yawl:hasSplit yawl:ControlTypeXor .
    # ... branch selection logic ...

    # GUARD: Only fire if no branch selected yet
    _:scope log:notIncludes { ?task kgc:xorBranchSelected true } .
}
=>
{
    ?next kgc:status "Active" .
    ?task kgc:xorBranchSelected true .  # Permanent marker
} .
\end{lstlisting}

\begin{definition}[Guard Marker]
A guard marker is a triple $(X, \texttt{guard}, \texttt{true})$ added to prevent rule re-firing.
\end{definition}

\begin{theorem}[Marker Permanence]
\label{thm:marker}
Guard markers are permanent; patterns using them can fire at most once per subject.
\end{theorem}

\begin{proof}
Let marker $M = (X, \texttt{guard}, \texttt{true})$ be added at tick $t$.

By Lemma \ref{lem:monotone}: $\forall t' > t: M \in \mathcal{G}_{t'}$.

The guard condition \texttt{log:notIncludes \{ X guard true \}} is false for all $t' > t$.

Therefore the rule cannot fire again for subject $X$.
\end{proof}

\section{Patterns Affected by Marker Permanence}

\begin{table}[h]
\centering
\begin{tabular}{llp{6cm}}
\toprule
\textbf{WCP} & \textbf{Name} & \textbf{Marker Effect} \\
\midrule
4 & Exclusive Choice & XOR decision permanent; task cannot re-execute \\
9 & Discriminator & Reset marker ineffective; deadlock on reuse \\
10 & Arbitrary Cycles & Loop marker prevents re-entry; single iteration only \\
16 & Deferred Choice & Choice resolution permanent \\
17 & Interleaved Parallel & Mutex release marker accumulates \\
28 & Blocking Discriminator & Block markers persist \\
29 & Cancelling Discriminator & Winner marker permanent \\
39 & Critical Section & Lock holder marker persists \\
\bottomrule
\end{tabular}
\caption{Patterns affected by marker permanence (8 total)}
\label{tab:marker-patterns}
\end{table}

\section{The Re-execution Problem}

\begin{definition}[Re-executable Pattern]
A pattern is \textbf{re-executable} if the same task can participate in the pattern multiple times during workflow execution.
\end{definition}

\begin{theorem}[Re-execution Impossibility]
\label{thm:reexec}
Patterns requiring re-execution cannot be implemented with guard markers.
\end{theorem}

\begin{proof}
\textbf{Case: WCP-10 Arbitrary Cycles}

A loop must execute its body $n$ times where $n$ is determined by a condition.

Implementation uses marker \texttt{kgc:cycleEdgeSelected}:
\begin{enumerate}
    \item Iteration 1: Condition true $\to$ back-edge fires, marker added
    \item Iteration 2: Condition still true, but marker exists $\to$ rule blocked
\end{enumerate}

The loop executes exactly once regardless of condition.

\textbf{Case: WCP-9 Discriminator}

A discriminator must:
\begin{enumerate}
    \item Fire on first arrival
    \item Consume subsequent arrivals
    \item Reset when all consumed
\end{enumerate}

Implementation sets \texttt{kgc:discriminatorState "fired"} on first arrival.

Reset rule adds \texttt{kgc:discriminatorState "waiting"}.

After reset, graph contains:
\[
\{(\texttt{disc}, \texttt{state}, \texttt{"fired"}), (\texttt{disc}, \texttt{state}, \texttt{"waiting"})\}
\]

The "fired" marker persists, and subsequent arrivals see both states.
\end{proof}

%==============================================================================
\chapter{The Classification Theorem}
%==============================================================================

\section{Pattern Classification}

We now present the main classification result.

\begin{definition}[Pattern Classes]
\begin{itemize}
    \item \textbf{Monotonic-Safe}: Correctly implementable in monotonic N3
    \item \textbf{Monotonic-Partial}: Implementable with restrictions (single execution)
    \item \textbf{Monotonic-Impossible}: Cannot be correctly implemented
\end{itemize}
\end{definition}

\begin{theorem}[Classification Theorem]
\label{thm:classification}
The 43 YAWL patterns partition as follows:
\begin{align}
|\text{Monotonic-Safe}| &= 5 \\
|\text{Monotonic-Partial}| &= 8 \\
|\text{Monotonic-Impossible}| &= 30
\end{align}
\end{theorem}

\begin{proof}
We establish membership by analyzing each pattern's requirements:

\textbf{Monotonic-Safe} (no state change, no counters, no re-execution):
\begin{itemize}
    \item WCP-1 (Sequence): Simple propagation
    \item WCP-2 (Parallel Split): N3 fires all bindings naturally
    \item WCP-5 (Simple Merge): First-arrival, no synchronization
    \item WCP-11 (Implicit Termination): Leaf detection, read-only
    \item WCP-24 (Persistent Trigger): Queue accumulation is monotonic
\end{itemize}

\textbf{Monotonic-Partial} (work once per task):
\begin{itemize}
    \item WCP-3 (Synchronization): Works if predecessors don't change
    \item WCP-4 (Exclusive Choice): Works once per decision point
    \item WCP-6 (Multi-Choice): Works once per split
    \item WCP-8 (Multi-Merge): Accumulates activations
    \item WCP-16 (Deferred Choice): Works once
    \item WCP-18 (Milestone): Single milestone check
    \item WCP-19 (Cancel Task): Idempotent cancellation
    \item WCP-23 (Transient Trigger): Single consumption
\end{itemize}

\textbf{Monotonic-Impossible} (30 patterns):
\begin{itemize}
    \item 14 patterns require counters (Table \ref{tab:counter-patterns})
    \item 8 patterns require marker reset (Table \ref{tab:marker-patterns})
    \item 8 patterns require external state setup or complex state machines
\end{itemize}
\end{proof}

\section{Characterization Criteria}

\begin{theorem}[Implementability Criteria]
\label{thm:criteria}
A workflow pattern is Monotonic-Safe if and only if:
\begin{enumerate}
    \item It requires no numeric comparison of accumulated values
    \item It requires no state reset or value update
    \item It requires no mutual exclusion beyond first-execution guards
    \item Its correctness does not depend on absence of prior executions
\end{enumerate}
\end{theorem}

\begin{proof}
$(\Rightarrow)$ If any criterion fails:
\begin{enumerate}
    \item Numeric comparison $\to$ Counter impossibility (Theorem \ref{thm:counter})
    \item State reset $\to$ Monotonicity violation (Lemma \ref{lem:monotone})
    \item Mutual exclusion $\to$ State machine impossibility (Theorem \ref{thm:state-machine})
    \item Prior execution dependence $\to$ Marker permanence (Theorem \ref{thm:marker})
\end{enumerate}

$(\Leftarrow)$ If all criteria hold, the pattern is expressible as pure inference over immutable facts with at-most-once firing guards.
\end{proof}

%==============================================================================
\chapter{The Main Impossibility Theorem}
%==============================================================================

\begin{theorem}[Main Impossibility]
\label{thm:main-impossibility}
A workflow engine using N3 rules, the EYE reasoner, and PyOxigraph as state storage cannot correctly implement more than 13 of the 43 YAWL Workflow Control Patterns (30.2\%), and only 5 patterns (11.6\%) have full correctness guarantees.
\end{theorem}

\begin{proof}
Combining results from previous chapters:

\textbf{Part 1: Upper bound (13 patterns)}

Patterns not requiring counters, reset, or complex state:
\[
43 - 14 \text{ (counters)} - 8 \text{ (markers)} - 8 \text{ (state machines)} = 13
\]

Note: Some patterns fall into multiple categories; the 30 impossible patterns account for overlap.

\textbf{Part 2: Strict correctness (5 patterns)}

Only Monotonic-Safe patterns have full correctness:
\begin{itemize}
    \item WCP-1, 2, 5, 11, 24
\end{itemize}

\textbf{Part 3: Partial correctness (8 patterns)}

Monotonic-Partial patterns work under restrictions:
\begin{itemize}
    \item WCP-3, 4, 6, 8, 16, 18, 19, 23
\end{itemize}

These fail on re-execution or accumulated state queries.
\end{proof}

%==============================================================================
\chapter{Empirical Validation}
%==============================================================================

\section{Gemba Testing Methodology}

Following Lean Six Sigma principles, we conducted "Gemba" (go and see) testing on the KGCL implementation.

\subsection{Test 1: Cycle Re-entry (WCP-10)}

\begin{lstlisting}[style=n3style, caption={WCP-10 Test Setup}]
<urn:task:Loop> a yawl:Task ;
    kgc:status "Completed" ;
    yawl:flowsInto <urn:flow:back> .

<urn:flow:back> yawl:nextElementRef <urn:task:Loop> ;
    yawl:isBackEdge true ;
    yawl:loopCondition <urn:cond:continue> .

<urn:cond:continue> kgc:evaluatesTo true .
\end{lstlisting}

\textbf{Result:}
\begin{itemize}
    \item Tick 1: $\Delta = 5$, marker \texttt{cycleEdgeSelected = true} added
    \item Tick 2: $\Delta = 0$, loop blocked by permanent marker
\end{itemize}

\textbf{Conclusion:} WCP-10 fires exactly once. \textbf{BROKEN.}

\subsection{Test 2: Status Pollution}

\begin{lstlisting}[style=n3style, caption={Status Transition Test}]
<urn:task:B> a yawl:Task ;
    kgc:status "Pending" .
\end{lstlisting}

After physics application:
\begin{verbatim}
<urn:task:B> kgc:status "Active" .
<urn:task:B> kgc:status "Pending" .  # Still exists!
\end{verbatim}

\textbf{Conclusion:} Multiple status values accumulate. \textbf{POLLUTION CONFIRMED.}

\subsection{Test 3: Counter Explosion}

Multi-Instance pattern with \texttt{math:sum}:

\begin{table}[h]
\centering
\begin{tabular}{ccc}
\toprule
\textbf{Tick} & \textbf{$\Delta$} & \textbf{Growth Factor} \\
\midrule
1 & 7 & -- \\
2 & 14 & 2.0$\times$ \\
3 & 28 & 2.0$\times$ \\
\bottomrule
\end{tabular}
\caption{Exponential growth observation}
\end{table}

Graph contained 8 distinct \texttt{spawnedCount} values after 3 ticks.

\textbf{Conclusion:} Exponential growth confirmed. \textbf{BROKEN.}

\section{Summary of Empirical Findings}

\begin{table}[h]
\centering
\begin{tabular}{llc}
\toprule
\textbf{Issue} & \textbf{Patterns Affected} & \textbf{Severity} \\
\midrule
Marker permanence & WCP 4, 9, 10, 16, 17, 28, 29, 39 & HIGH \\
Status pollution & All patterns & MEDIUM \\
Counter explosion & WCP 12--15, 21--22, 28--36, 41--42 & CRITICAL \\
\bottomrule
\end{tabular}
\caption{Empirical validation summary}
\end{table}

%==============================================================================
\chapter{Architectural Implications}
%==============================================================================

\section{Why N3 Seemed Suitable}

The initial appeal of N3 for workflow:

\begin{enumerate}
    \item \textbf{Pattern matching}: N3 excels at graph pattern matching
    \item \textbf{Inference chains}: Multi-step deduction is natural
    \item \textbf{Semantic grounding}: Patterns as ontology, not code
\end{enumerate}

\section{The Fundamental Mismatch}

\begin{quote}
\textit{N3 was designed for proving facts about the world. \\
Workflow execution requires changing the world.}
\end{quote}

\begin{table}[h]
\centering
\begin{tabular}{p{5cm}p{5cm}}
\toprule
\textbf{N3/Logic Systems} & \textbf{Workflow Engines} \\
\midrule
Monotonic (facts accumulate) & State machines (states change) \\
Inference (derive new facts) & Execution (perform actions) \\
Timeless (logical truth) & Temporal (event ordering) \\
Set semantics (unordered) & Sequence semantics (ordered) \\
\bottomrule
\end{tabular}
\caption{Paradigm mismatch}
\end{table}

\section{Recommended Architecture}

We propose a hybrid architecture:

\begin{tikzpicture}[node distance=2cm]
    \node[draw, rectangle, minimum width=3cm] (state) {PyOxigraph\\(State Storage)};
    \node[draw, rectangle, minimum width=3cm, right=of state] (eye) {EYE Reasoner\\(Guard Evaluation)};
    \node[draw, rectangle, minimum width=3cm, below=of state] (sparql) {SPARQL UPDATE\\(State Mutation)};
    \node[draw, rectangle, minimum width=3cm, below=of eye] (python) {Python\\(Orchestration)};

    \draw[->] (state) -- node[above] {Export} (eye);
    \draw[->] (eye) -- node[right] {Guards OK?} (python);
    \draw[->] (python) -- node[below] {DELETE/INSERT} (sparql);
    \draw[->] (sparql) -- node[left] {Mutate} (state);
\end{tikzpicture}

\textbf{Key change:} N3 rules only evaluate \textit{preconditions}; Python + SPARQL UPDATE performs \textit{mutations}.

This preserves semantic grounding while enabling proper state management.

%==============================================================================
\chapter{Conclusion}
%==============================================================================

\section{Summary of Contributions}

This thesis has established:

\begin{enumerate}
    \item \textbf{Formal impossibility}: 30 of 43 YAWL patterns cannot be correctly implemented in monotonic N3/EYE/PyOxigraph systems

    \item \textbf{Classification theorem}: Patterns partition into Safe (5), Partial (8), and Impossible (30) classes

    \item \textbf{Root causes}: Monotonicity, counter impossibility, and marker permanence

    \item \textbf{Empirical validation}: KGCL testing confirms theoretical predictions
\end{enumerate}

\section{Practical Recommendations}

For practitioners:

\begin{enumerate}
    \item \textbf{Do not claim} full WCP support with N3-only architectures
    \item \textbf{Use hybrid architectures} combining inference with imperative updates
    \item \textbf{Document limitations} when using N3 for workflow
    \item \textbf{Consider alternatives}: Camunda, Temporal, or custom state machines
\end{enumerate}

\section{Future Work}

\begin{enumerate}
    \item Formal verification of hybrid architecture correctness
    \item Performance comparison: Pure N3 vs. hybrid vs. traditional engines
    \item Extension to data and resource patterns
    \item Non-monotonic N3 extensions (with controlled retraction)
\end{enumerate}

\section{Closing Remarks}

The Semantic Web provides powerful tools for knowledge representation and inference. However, \textbf{inference is not execution}. Workflow patterns demand state change, which monotonic systems cannot provide.

This is not a failure of N3 or semantic technologies---it is a category error in application. By understanding the boundaries of monotonic reasoning, we can build systems that leverage semantic technologies appropriately while avoiding architectural dead ends.

\begin{quote}
\textit{``Know the tools. Know their limits. Build accordingly.''}
\end{quote}

%==============================================================================
% Bibliography
%==============================================================================

\begin{thebibliography}{99}

\bibitem{vanderaalst2003}
van der Aalst, W.M.P., ter Hofstede, A.H.M., Kiepuszewski, B., \& Barros, A.P. (2003).
Workflow Patterns.
\textit{Distributed and Parallel Databases}, 14(1), 5--51.

\bibitem{russell2006}
Russell, N., ter Hofstede, A.H.M., van der Aalst, W.M.P., \& Mulyar, N. (2006).
Workflow Control-Flow Patterns: A Revised View.
\textit{BPM Center Report BPM-06-22}.

\bibitem{berners2008n3}
Berners-Lee, T., Connolly, D., Kagal, L., Scharf, Y., \& Hendler, J. (2008).
N3Logic: A logical framework for the World Wide Web.
\textit{Theory and Practice of Logic Programming}, 8(3), 249--269.

\bibitem{martin2004owls}
Martin, D., et al. (2004).
OWL-S: Semantic Markup for Web Services.
\textit{W3C Member Submission}.

\bibitem{fensel2006wsmo}
Fensel, D., et al. (2006).
Enabling Semantic Web Services: The Web Service Modeling Ontology.
\textit{Springer}.

\bibitem{horrocks2004swrl}
Horrocks, I., et al. (2004).
SWRL: A Semantic Web Rule Language Combining OWL and RuleML.
\textit{W3C Member Submission}.

\bibitem{debruijn2005rif}
de Bruijn, J., et al. (2005).
The Rule Interchange Format.
\textit{W3C Working Group}.

\bibitem{eye2023}
De Roo, J. (2023).
EYE: Euler Yet another proof Engine.
\url{https://github.com/eyereasoner/eye}

\bibitem{oxigraph2023}
Tanon, T.P. (2023).
Oxigraph: A SPARQL database written in Rust.
\url{https://github.com/oxigraph/oxigraph}

\bibitem{yawl2023}
ter Hofstede, A.H.M., et al. (2023).
YAWL: Yet Another Workflow Language.
\url{http://www.yawlfoundation.org/}

\end{thebibliography}

%==============================================================================
% Appendices
%==============================================================================

\appendix

\chapter{Complete Pattern Classification}

\begin{table}[h]
\centering
\small
\begin{tabular}{clccc}
\toprule
\textbf{WCP} & \textbf{Name} & \textbf{Class} & \textbf{Barrier} \\
\midrule
1 & Sequence & Safe & -- \\
2 & Parallel Split & Safe & -- \\
3 & Synchronization & Partial & Negation complexity \\
4 & Exclusive Choice & Partial & Single execution \\
5 & Simple Merge & Safe & -- \\
6 & Multi-Choice & Partial & Single execution \\
7 & Structured Sync Merge & Impossible & External count setup \\
8 & Multi-Merge & Partial & Accumulates activations \\
9 & Structured Discriminator & Impossible & Reset fails \\
10 & Arbitrary Cycles & Impossible & Single iteration \\
11 & Implicit Termination & Safe & -- \\
12 & MI Without Sync & Impossible & Counter \\
13 & MI Design-Time & Impossible & Counter \\
14 & MI Runtime & Impossible & Counter \\
15 & MI No A Priori & Impossible & Counter + phase \\
16 & Deferred Choice & Partial & Single execution \\
17 & Interleaved Parallel & Impossible & Mutex release \\
18 & Milestone & Partial & Single check \\
19 & Cancel Task & Partial & Idempotent \\
20 & Cancel Case & Impossible & Cascade + membership \\
21 & Structured Loop & Impossible & Counter \\
22 & Recursion & Impossible & Counter \\
23 & Transient Trigger & Partial & Single consumption \\
24 & Persistent Trigger & Safe & -- \\
25 & Cancel Region & Impossible & Cascade + membership \\
26 & Cancel MI Activity & Impossible & Instance tracking \\
27 & Complete MI Activity & Impossible & Complex state machine \\
28 & Blocking Discriminator & Impossible & Counter + reset \\
29 & Cancelling Discriminator & Impossible & Winner protection \\
30 & Structured Partial Join & Impossible & Counter \\
31 & Blocking Partial Join & Impossible & Counter + reset \\
32 & Cancelling Partial Join & Impossible & Counter + cancel \\
33 & Generalized AND-Join & Impossible & Dynamic count \\
34 & Static Partial Join MI & Impossible & Counter \\
35 & Cancelling Partial Join MI & Impossible & Counter + cancel \\
36 & Dynamic Partial Join MI & Impossible & Counter \\
37 & Local Sync Merge & Impossible & Context tracking \\
38 & General Sync Merge & Impossible & Path tracking \\
39 & Critical Section & Impossible & Lock release \\
40 & Interleaved Routing & Impossible & Current task \\
41 & Thread Merge & Impossible & Counter \\
42 & Thread Split & Impossible & Counter \\
43 & Explicit Termination & Impossible & Cascade + membership \\
\bottomrule
\end{tabular}
\caption{Complete pattern classification}
\end{table}

\chapter{N3 Rule Listings}

Selected rules demonstrating the architectural issues are available in the KGCL repository at:

\texttt{src/kgcl/hybrid/wcp43\_physics.py}

\end{document}
